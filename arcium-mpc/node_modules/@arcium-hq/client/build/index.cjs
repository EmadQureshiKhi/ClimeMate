'use strict';

var crypto = require('crypto');
var ed25519 = require('@noble/curves/ed25519');
var sha3 = require('@noble/hashes/sha3');
var modular = require('@noble/curves/abstract/modular');
var anchor = require('@coral-xyz/anchor');
var utils = require('@noble/hashes/utils');
var edwards = require('@noble/curves/abstract/edwards');
var web3_js = require('@solana/web3.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var anchor__namespace = /*#__PURE__*/_interopNamespaceDefault(anchor);

/**
 * Scalar field prime modulus for Curve25519: 2^252 + 27742317777372353535851937790883648493
 */
const CURVE25519_SCALAR_FIELD_MODULUS = ed25519.ed25519.CURVE.n;
/**
 * Generates a random value within the field bound by q.
 * @param q - The upper bound (exclusive) for the random value.
 * @returns A random bigint value between 0 and q-1.
 */
function generateRandomFieldElem(q) {
    const byteLength = (q.toString(2).length + 7) >> 3;
    let r;
    do {
        const randomBuffer = crypto.randomBytes(byteLength);
        r = BigInt(`0x${randomBuffer.toString('hex')}`);
    } while (r >= q);
    return r;
}
/**
 * Computes the positive modulo of a over m.
 * @param a - The dividend.
 * @param m - The modulus.
 * @returns The positive remainder of a mod m.
 */
function positiveModulo(a, m) {
    return ((a % m) + m) % m;
}
/**
 * Serializes a bigint to a little-endian Uint8Array of the specified length.
 * @param val - The bigint value to serialize.
 * @param lengthInBytes - The desired length of the output array.
 * @returns The serialized value as a Uint8Array.
 * @throws Error if the value is too large for the specified length.
 */
function serializeLE(val, lengthInBytes) {
    const result = new Uint8Array(lengthInBytes);
    let tempVal = val;
    for (let i = 0; i < lengthInBytes; i++) {
        result[i] = Number(tempVal & BigInt(255));
        tempVal >>= BigInt(8);
    }
    if (tempVal > BigInt(0)) {
        throw new Error(`Value ${val} is too large for the byte length ${lengthInBytes}`);
    }
    return result;
}
/**
 * Deserializes a little-endian Uint8Array to a bigint.
 * @param bytes - The Uint8Array to deserialize.
 * @returns The deserialized bigint value.
 */
function deserializeLE(bytes) {
    let result = BigInt(0);
    for (let i = 0; i < bytes.length; i++) {
        result |= BigInt(bytes[i]) << (BigInt(i) * BigInt(8));
    }
    return result;
}
// GENERAL
/**
 * Computes the SHA-256 hash of an array of Uint8Arrays.
 * @param byteArrays - The arrays to hash.
 * @returns The SHA-256 hash as a Buffer.
 */
function sha256(byteArrays) {
    const hash = crypto.createHash('sha256');
    byteArrays.forEach((byteArray) => {
        hash.update(byteArray);
    });
    return hash.digest();
}

/**
 * Converts a bigint to an array of bits (least significant to most significant, in 2's complement representation).
 * @param x - The bigint to convert.
 * @param binSize - The number of bits to use in the representation.
 * @returns An array of booleans representing the bits of x.
 */
function toBinLE(x, binSize) {
    const res = [];
    for (let i = 0; i < binSize; ++i) {
        res.push(ctSignBit(x, BigInt(i)));
    }
    return res;
}
/**
 * Converts an array of bits (least significant to most significant, in 2's complement representation) to a bigint.
 * @param xBin - The array of bits to convert.
 * @returns The bigint represented by the bit array.
 */
function fromBinLE(xBin) {
    let res = 0n;
    for (let i = 0; i < xBin.length - 1; ++i) {
        res |= BigInt(xBin[i]) << BigInt(i);
    }
    return res - (BigInt(xBin[xBin.length - 1]) << BigInt(xBin.length - 1));
}
/**
 * Binary adder between x and y (assumes xBin and yBin are of the same length and large enough to represent the sum).
 * @param xBin - The first operand as a bit array.
 * @param yBin - The second operand as a bit array.
 * @param carryIn - The initial carry-in value.
 * @param binSize - The number of bits to use in the operation.
 * @returns The sum as a bit array.
 */
function adder(xBin, yBin, carryIn, binSize) {
    const res = [];
    let carry = carryIn;
    for (let i = 0; i < binSize; ++i) {
        // res[i] = xBin[i] XOR yBin[i] XOR carry
        const yXorCarry = yBin[i] !== carry;
        res.push(xBin[i] !== yXorCarry);
        // newCarry = (xBin[i] AND yBin[i]) XOR (xBin[i] AND carry) XOR (yBin[i] AND carry)
        //          = (yBin[i] XOR carry) ? xBin[i] : yBin[i]
        const newCarry = yBin[i] !== (yXorCarry && (xBin[i] !== yBin[i]));
        carry = newCarry;
    }
    return res;
}
/**
 * Constant-time addition of two bigints, using 2's complement representation.
 * @param x - The first operand.
 * @param y - The second operand.
 * @param binSize - The number of bits to use in the operation.
 * @returns The sum as a bigint.
 */
function ctAdd(x, y, binSize) {
    const resBin = adder(toBinLE(x, binSize), toBinLE(y, binSize), false, binSize);
    return fromBinLE(resBin);
}
/**
 * Constant-time subtraction of two bigints, using 2's complement representation.
 * @param x - The first operand.
 * @param y - The second operand.
 * @param binSize - The number of bits to use in the operation.
 * @returns The difference as a bigint.
 */
function ctSub(x, y, binSize) {
    const yBin = toBinLE(y, binSize);
    const yBinNot = [];
    for (let i = 0; i < binSize; ++i) {
        yBinNot.push(yBin[i] === false);
    }
    const resBin = adder(toBinLE(x, binSize), yBinNot, true, binSize);
    return fromBinLE(resBin);
}
/**
 * Returns the sign bit of a bigint in constant time.
 * @param x - The bigint to check.
 * @param binSize - The bit position to check (typically the highest bit).
 * @returns True if the sign bit is set, false otherwise.
 */
function ctSignBit(x, binSize) {
    return ((x >> binSize) & 1n) === 1n;
}
/**
 * Constant-time less-than comparison for two bigints.
 * @param x - The first operand.
 * @param y - The second operand.
 * @param binSize - The number of bits to use in the operation.
 * @returns True if x < y, false otherwise.
 */
function ctLt(x, y, binSize) {
    return ctSignBit(ctSub(x, y, binSize), binSize);
}
/**
 * Constant-time select between two bigints based on a boolean condition.
 * @param b - The condition; if true, select x, otherwise select y.
 * @param x - The value to select if b is true.
 * @param y - The value to select if b is false.
 * @param binSize - The number of bits to use in the operation.
 * @returns The selected bigint.
 */
function ctSelect(b, x, y, binSize) {
    return ctAdd(y, BigInt(b) * (ctSub(x, y, binSize)), binSize);
}
/**
 * Checks if a bigint fits in the range -2^binSize <= x < 2^binSize.
 * Not constant-time for arbitrary x, but is constant-time for all inputs for which the function returns true.
 * If you assert your inputs satisfy verifyBinSize(x, binSize), you need not care about the non constant-timeness of this function.
 * @param x - The bigint to check.
 * @param binSize - The number of bits to use in the check.
 * @returns True if x fits in the range, false otherwise.
 */
function verifyBinSize(x, binSize) {
    const bin = (x >> binSize).toString(2);
    return bin === '0' || bin === '-1';
}

function isBrowser() {
    return (
    // eslint-disable-next-line no-prototype-builtins
    typeof window !== 'undefined' && !window.process?.hasOwnProperty('type'));
}
function optionalLog(log, ...args) {
    if (log) {
        // eslint-disable-next-line no-console
        console.log(...args);
    }
}
function getBinSize(max) {
    // floor(log2(max)) + 1 to represent unsigned elements, a +1 for signed elements
    // and another +1 to account for the diff of two negative elements
    return BigInt(Math.floor(Math.log2(Number(max)))) + 3n;
}
/**
 * Compresses an array of bytes into 128-bit bigints.
 *
 * Takes an array of bytes whose length is a multiple of 16 and compresses each consecutive 16 bytes into a single 128-bit bigint.
 *
 * @param bytes - The input byte array. Its length must be a multiple of 16.
 * @returns An array of 128-bit bigints, each representing 16 bytes from the input.
 * @throws Error if the input length is not a multiple of 16.
 */
function compressUint128(bytes) {
    if (bytes.length % 16 !== 0) {
        throw Error(`bytes.length must be a multiple of 16 (found ${bytes.length})`);
    }
    const res = [];
    for (let n = 0; n < bytes.length / 16; ++n) {
        res.push(deserializeLE(bytes.slice(n * 16, (n + 1) * 16)));
    }
    return res;
}
/**
 * Decompresses an array of 128-bit bigints into a flattened byte array.
 *
 * Takes an array of 128-bit bigints and returns a Uint8Array containing the decompressed bytes (16 bytes per bigint).
 *
 * @param compressed - The input array of 128-bit bigints. Each bigint must be less than 2^128.
 * @returns A Uint8Array containing the decompressed bytes.
 * @throws Error if any bigint in the input is not less than 2^128.
 */
function decompressUint128(compressed) {
    compressed.forEach((c) => {
        if (c >= 1n << 128n) {
            throw Error(`input must be less than 2^128 (found ${c})`);
        }
    });
    const res = [];
    for (let n = 0; n < compressed.length; ++n) {
        res.push(...serializeLE(compressed[n], 16));
    }
    return new Uint8Array(res);
}

/**
 * Matrix class over FpField. Data is row-major.
 */
class Matrix {
    field;
    data;
    constructor(field, data) {
        this.field = field;
        const nrows = data.length;
        const ncols = data[0].length;
        for (let i = 1; i < nrows; ++i) {
            if (data[i].length !== ncols) {
                throw Error('All rows must have same number of columns.');
            }
        }
        this.data = data.map((row) => row.map((c) => field.create(c)));
    }
    /**
     * Matrix multiplication between `this` and `rhs`.
     */
    matMul(rhs) {
        const thisNrows = this.data.length;
        const thisNcols = this.data[0].length;
        const rhsNrows = rhs.data.length;
        const rhsNcols = rhs.data[0].length;
        if (thisNcols !== rhsNrows) {
            throw Error(`this.ncols must be equal to rhs.nrows (found ${thisNcols} and ${rhsNrows})`);
        }
        const data = [];
        for (let i = 0; i < thisNrows; ++i) {
            const row = [];
            for (let j = 0; j < rhsNcols; ++j) {
                let c = this.field.ZERO;
                for (let k = 0; k < thisNcols; ++k) {
                    c = this.field.add(c, this.field.mul(this.data[i][k], rhs.data[k][j]));
                }
                row.push(c);
            }
            data.push(row);
        }
        return new Matrix(this.field, data);
    }
    /**
     * Element-wise addition between `this` and `rhs`.
     */
    add(rhs, ct = false) {
        const thisNrows = this.data.length;
        const thisNcols = this.data[0].length;
        const rhsNrows = rhs.data.length;
        const rhsNcols = rhs.data[0].length;
        if (thisNrows !== rhsNrows) {
            throw Error(`this.nrows must be equal to rhs.nrows (found ${thisNrows} and ${rhsNrows})`);
        }
        if (thisNcols !== rhsNcols) {
            throw Error(`this.ncols must be equal to rhs.ncols (found ${thisNcols} and ${rhsNcols})`);
        }
        const binSize = getBinSize(this.field.ORDER - 1n);
        const data = [];
        for (let i = 0; i < thisNrows; ++i) {
            const row = [];
            for (let j = 0; j < thisNcols; ++j) {
                if (ct) {
                    const sum = ctAdd(this.data[i][j], rhs.data[i][j], binSize);
                    row.push(ctSelect(ctLt(sum, this.field.ORDER, binSize), sum, ctSub(sum, this.field.ORDER, binSize), binSize));
                }
                else {
                    row.push(this.field.add(this.data[i][j], rhs.data[i][j]));
                }
            }
            data.push(row);
        }
        return new Matrix(this.field, data);
    }
    /**
     * Element-wise subtraction between `this` and `rhs`.
     */
    sub(rhs, ct = false) {
        const thisNrows = this.data.length;
        const thisNcols = this.data[0].length;
        const rhsNrows = rhs.data.length;
        const rhsNcols = rhs.data[0].length;
        if (thisNrows !== rhsNrows) {
            throw Error(`this.nrows must be equal to rhs.nrows (found ${thisNrows} and ${rhsNrows})`);
        }
        if (thisNcols !== rhsNcols) {
            throw Error(`this.ncols must be equal to rhs.ncols (found ${thisNcols} and ${rhsNcols})`);
        }
        const binSize = getBinSize(this.field.ORDER - 1n);
        const data = [];
        for (let i = 0; i < thisNrows; ++i) {
            const row = [];
            for (let j = 0; j < thisNcols; ++j) {
                if (ct) {
                    const diff = ctSub(this.data[i][j], rhs.data[i][j], binSize);
                    row.push(ctSelect(ctSignBit(diff, binSize), ctAdd(diff, this.field.ORDER, binSize), diff, binSize));
                }
                else {
                    row.push(this.field.sub(this.data[i][j], rhs.data[i][j]));
                }
            }
            data.push(row);
        }
        return new Matrix(this.field, data);
    }
    /**
     * Raises each element of `this` to the power `e`.
     */
    pow(e) {
        const data = [];
        for (let i = 0; i < this.data.length; ++i) {
            const row = [];
            for (let j = 0; j < this.data[0].length; ++j) {
                row.push(this.field.pow(this.data[i][j], e));
            }
            data.push(row);
        }
        return new Matrix(this.field, data);
    }
    /**
     * computs the determinant using gaus elimination
     * matches the determinant implementation in arcis
     */
    det() {
        // Ensure the matrix is square
        const n = this.data.length;
        if (n === 0 || !this.is_square()) {
            throw Error('Matrix must be square and non-empty to compute the determinant.');
        }
        let det = this.field.ONE;
        // Clone the data to avoid mutating the original matrix
        let rows = this.data.map((row) => [...row]);
        for (let i = 0; i < n; ++i) {
            // we partition into rows that have a leading zero and rows that don't
            const lzRows = rows.filter((r) => this.field.is0(r[0]));
            const nlzRows = rows.filter((r) => !this.field.is0(r[0]));
            // take pivot element
            const pivotRow = nlzRows.shift();
            if (pivotRow === undefined) {
                // no pivot row implies the rank is less than n i.e. the determinant is zero
                return this.field.ZERO;
            }
            const pivot = pivotRow[0];
            // multiply pivot onto the determinant
            det = this.field.mul(det, pivot);
            // subtract all leading non zero values with the pivot element (forward elimination).
            const pivotInverse = this.field.inv(pivot);
            // precomputing pivot row such that the leading value is one. This reduces the number of
            // multiplications in the forward elimination multiplications by 50%
            const normalizedPivotRow = pivotRow.map((v) => this.field.mul(pivotInverse, v));
            // forward elimination with normalized pivot row
            const nlzRowsProcessed = nlzRows.map((row) => {
                const lead = row[0];
                return row.map((value, index) => this.field.sub(value, this.field.mul(lead, normalizedPivotRow[index])));
            });
            // concat the reamining rows (without pivot row) and remove the pivot column (all first
            // elements (i.e. zeros) from the remaining rows).
            rows = nlzRowsProcessed.concat(lzRows).map((row) => row.slice(1));
        }
        return det;
    }
    is_square() {
        const n = this.data.length;
        for (let i = 1; i < n; ++i) {
            if (this.data[i].length !== n) {
                return false;
            }
        }
        return true;
    }
}
function randMatrix(field, nrows, ncols) {
    const data = [];
    for (let i = 0; i < nrows; ++i) {
        const row = [];
        for (let j = 0; j < ncols; ++j) {
            row.push(generateRandomFieldElem(field.ORDER));
        }
        data.push(row);
    }
    return new Matrix(field, data);
}

/**
 * Curve25519 base field as an IField instance.
 */
const CURVE25519_BASE_FIELD = ed25519.ed25519.CURVE.Fp;
// hardcode security level to 128 bits
const SECURITY_LEVEL = 128;
// We refer to https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287 for more details.
/**
 * Description and parameters for the Rescue cipher or hash function, including round constants, MDS matrix, and key schedule.
 * See: https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287
 */
class RescueDesc {
    mode;
    field;
    // The smallest prime that does not divide p-1.
    alpha;
    // The inverse of alpha modulo p-1.
    alphaInverse;
    nRounds;
    m;
    // A Maximum Distance Separable matrix.
    mdsMat;
    // Its inverse.
    mdsMatInverse;
    // The round keys, needed for encryption and decryption.
    roundKeys;
    /**
     * Constructs a RescueDesc for a given field and mode (cipher or hash).
     * Initializes round constants, MDS matrix, and key schedule.
     * @param field - The field to use (e.g., CURVE25519_BASE_FIELD).
     * @param mode - The mode: block cipher or hash function.
     */
    constructor(field, mode) {
        this.field = field;
        this.mode = mode;
        switch (this.mode.kind) {
            case 'cipher': {
                this.m = this.mode.key.length;
                if (this.m < 2) {
                    throw Error(`parameter m must be at least 2 (found ${this.m})`);
                }
                break;
            }
            case 'hash': {
                this.m = this.mode.m;
                break;
            }
            default: {
                this.m = 0;
                break;
            }
        }
        const alphaAndInverse = getAlphaAndInverse(this.field.ORDER);
        this.alpha = alphaAndInverse[0];
        this.alphaInverse = alphaAndInverse[1];
        this.nRounds = getNRounds(this.field.ORDER, this.mode, this.alpha, this.m);
        const mdsMatrixAndInverse = getMdsMatrixAndInverse(this.field, this.m);
        this.mdsMat = mdsMatrixAndInverse[0];
        this.mdsMatInverse = mdsMatrixAndInverse[1];
        // generate the round constants using SHAKE256
        const roundConstants = this.sampleConstants(this.nRounds);
        switch (this.mode.kind) {
            case 'cipher': {
                // do the key schedule
                this.roundKeys = rescuePermutation(this.mode, this.alpha, this.alphaInverse, this.mdsMat, roundConstants, new Matrix(this.field, toVec(this.mode.key)));
                break;
            }
            case 'hash': {
                this.roundKeys = roundConstants;
                break;
            }
            default: {
                this.roundKeys = [];
                break;
            }
        }
    }
    /**
     * Samples round constants for the Rescue permutation, using SHAKE256.
     * @param nRounds - The number of rounds.
     * @returns An array of round constant matrices.
     */
    sampleConstants(nRounds) {
        const field = this.field;
        const m = this.m;
        // setup randomness
        // dkLen is the output length from the Keccak instance behind shake.
        // this is irrelevant for our extendable output function (xof), but still we use
        // the default value from one-time shake256 hashing, as defined in shake256's definition
        // in noble-hashes-sha3.
        const hasher = sha3.shake256.create({ dkLen: 256 / 8 });
        // buffer to create field elements from bytes
        // we add 16 bytes to get a distribution statistically close to uniform
        const bufferLen = Math.ceil(field.BITS / 8) + 16;
        switch (this.mode.kind) {
            case 'cipher': {
                hasher.update('encrypt everything, compute anything');
                const rFieldArray = Array.from({ length: m * m + 2 * m }, () => {
                    // create field element from the shake hash
                    const randomness = hasher.xof(bufferLen);
                    // we need not check whether the obtained field element f is in any subgroup,
                    // because we use only prime fields (i.e. there are no subgroups)
                    return field.create(deserializeLE(randomness));
                });
                // create matrix and vectors
                const matData = Array.from({ length: m }, () => rFieldArray.splice(0, m));
                let roundConstantMat = new Matrix(field, matData);
                const initData = Array.from({ length: m }, () => rFieldArray.splice(0, 1));
                const initialRoundConstant = new Matrix(field, initData);
                const roundData = Array.from({ length: m }, () => rFieldArray.splice(0, 1));
                const roundConstantAffineTerm = new Matrix(field, roundData);
                // check for inversability
                while (field.is0(roundConstantMat.det())) {
                    // resample matrix
                    const resampleArray = Array.from({ length: m * m }, () => {
                        const randomness = hasher.xof(bufferLen);
                        return field.create(deserializeLE(randomness));
                    });
                    const resampleData = Array.from({ length: m }, () => resampleArray.splice(0, m));
                    roundConstantMat = new Matrix(field, resampleData);
                }
                const roundConstants = [initialRoundConstant];
                for (let r = 0; r < 2 * this.nRounds; ++r) {
                    roundConstants.push(roundConstantMat.matMul(roundConstants[r]).add(roundConstantAffineTerm));
                }
                return roundConstants;
            }
            case 'hash': {
                hasher.update(`Rescue-XLIX(${this.field.ORDER},${m},${this.mode.capacity},${SECURITY_LEVEL})`);
                // this.permute requires an odd number of round keys
                // prepending a 0 matrix makes it equivalent to Algorithm 3 from https://eprint.iacr.org/2020/1143.pdf
                const zeros = [];
                for (let i = 0; i < m; ++i) {
                    zeros.push([0n]);
                }
                const roundConstants = [new Matrix(field, zeros)];
                const rFieldArray = Array.from({ length: 2 * m * nRounds }, () => {
                    // create field element from the shake hash
                    const randomness = hasher.xof(bufferLen);
                    // we need not check whether the obtained field element f is in any subgroup,
                    // because we use only prime fields (i.e. there are no subgroups)
                    return field.create(deserializeLE(randomness));
                });
                for (let r = 0; r < 2 * nRounds; ++r) {
                    const data = [];
                    for (let i = 0; i < m; ++i) {
                        data.push([rFieldArray[r * m + i]]);
                    }
                    roundConstants.push(new Matrix(field, data));
                }
                return roundConstants;
            }
            default: return [];
        }
    }
    /**
     * Applies the Rescue permutation to a state matrix.
     * @param state - The input state matrix.
     * @returns The permuted state matrix.
     */
    permute(state) {
        return rescuePermutation(this.mode, this.alpha, this.alphaInverse, this.mdsMat, this.roundKeys, state)[2 * this.nRounds];
    }
    /**
     * Applies the inverse Rescue permutation to a state matrix.
     * @param state - The input state matrix.
     * @returns The inverse-permuted state matrix.
     */
    permuteInverse(state) {
        return rescuePermutationInverse(this.mode, this.alpha, this.alphaInverse, this.mdsMatInverse, this.roundKeys, state)[2 * this.nRounds];
    }
}
function getAlphaAndInverse(p) {
    const pMinusOne = p - 1n;
    let alpha = 0n;
    for (const a of [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n]) {
        if (pMinusOne % a !== 0n) {
            alpha = a;
            break;
        }
    }
    if (alpha === 0n) {
        throw Error('Could not find prime alpha that does not divide p-1.');
    }
    const alphaInverse = modular.invert(alpha, pMinusOne);
    return [alpha, alphaInverse];
}
function getNRounds(p, mode, alpha, m) {
    function dcon(n) {
        return Math.floor(0.5 * (Number(alpha) - 1) * m * (n - 1) + 2.0);
    }
    function v(n, rate) {
        return m * (n - 1) + rate;
    }
    function binomial(n, k) {
        function factorial(x) {
            if (x === 0n || x === 1n) {
                return 1n;
            }
            return x * factorial(x - 1n);
        }
        return factorial(BigInt(n)) / (factorial(BigInt(n - k)) * factorial(BigInt(k)));
    }
    switch (mode.kind) {
        case 'cipher': {
            const l0 = Math.ceil((2 * SECURITY_LEVEL) / ((m + 1) * (Math.log2(Number(p)) - Math.log2(Number(alpha) - 1))));
            let l1 = 0;
            if (alpha === 3n) {
                l1 = Math.ceil((SECURITY_LEVEL + 2) / (4 * m));
            }
            else {
                l1 = Math.ceil((SECURITY_LEVEL + 3) / (5.5 * m));
            }
            return 2 * Math.max(l0, l1, 5);
        }
        case 'hash': {
            // get number of rounds for Groebner basis attack
            const rate = m - mode.capacity;
            const target = 1n << BigInt(SECURITY_LEVEL);
            let l1 = 1;
            let tmp = binomial(v(l1, rate) + dcon(l1), v(l1, rate));
            while (tmp * tmp <= target && l1 <= 23) {
                l1 += 1;
                tmp = binomial(v(l1, rate) + dcon(l1), v(l1, rate));
            }
            // set a minimum value for sanity and add 50%
            return Math.ceil(1.5 * Math.max(5, l1));
        }
        default: return 0;
    }
}
function buildCauchy(field, size) {
    const data = [];
    for (let i = 1n; i <= size; ++i) {
        const row = [];
        for (let j = 1n; j <= size; ++j) {
            row.push(field.inv(i + j));
        }
        data.push(row);
    }
    return new Matrix(field, data);
}
function buildInverseCauchy(field, size) {
    function product(arr) {
        return arr.reduce((acc, curr) => field.mul(acc, field.create(curr)), field.ONE);
    }
    function prime(arr, val) {
        return product(arr.map((u) => {
            if (u !== val) {
                return val - u;
            }
            return 1n;
        }));
    }
    const data = [];
    for (let i = 1n; i <= size; ++i) {
        const row = [];
        for (let j = 1n; j <= size; ++j) {
            const a = product(Array.from({ length: size }, (_, key) => -i - BigInt(1 + key)));
            const aPrime = prime(Array.from({ length: size }, (_, key) => BigInt(1 + key)), j);
            const b = product(Array.from({ length: size }, (_, key) => j + BigInt(1 + key)));
            const bPrime = prime(Array.from({ length: size }, (_, key) => -BigInt(1 + key)), -i);
            row.push(field.mul(a, field.mul(b, field.mul(field.inv(aPrime), field.mul(field.inv(bPrime), field.inv(-i - j))))));
        }
        data.push(row);
    }
    return new Matrix(field, data);
}
function getMdsMatrixAndInverse(field, m) {
    const mdsMat = buildCauchy(field, m);
    const mdsMatInverse = buildInverseCauchy(field, m);
    return [mdsMat, mdsMatInverse];
}
function exponentForEven(mode, alpha, alphaInverse) {
    switch (mode.kind) {
        case 'cipher': {
            return alphaInverse;
        }
        case 'hash': {
            return alpha;
        }
        default: return 0n;
    }
}
function exponentForOdd(mode, alpha, alphaInverse) {
    switch (mode.kind) {
        case 'cipher': {
            return alpha;
        }
        case 'hash': {
            return alphaInverse;
        }
        default: return 0n;
    }
}
function rescuePermutation(mode, alpha, alphaInverse, mdsMat, subkeys, state) {
    const exponentEven = exponentForEven(mode, alpha, alphaInverse);
    const exponentOdd = exponentForOdd(mode, alpha, alphaInverse);
    const states = [state.add(subkeys[0])];
    for (let r = 0; r < subkeys.length - 1; ++r) {
        let s = states[r];
        if (r % 2 === 0) {
            s = s.pow(exponentEven);
        }
        else {
            s = s.pow(exponentOdd);
        }
        states.push(mdsMat.matMul(s).add(subkeys[r + 1]));
    }
    return states;
}
function rescuePermutationInverse(mode, alpha, alphaInverse, mdsMatInverse, subkeys, state) {
    const exponentEven = exponentForEven(mode, alpha, alphaInverse);
    const exponentOdd = exponentForOdd(mode, alpha, alphaInverse);
    // the initial state will need to be removed afterwards
    const states = [state];
    for (let r = 0; r < subkeys.length - 1; ++r) {
        let s = states[r];
        s = mdsMatInverse.matMul(s.sub(subkeys[subkeys.length - 1 - r]));
        if (r % 2 === 0) {
            s = s.pow(exponentEven);
        }
        else {
            s = s.pow(exponentOdd);
        }
        states.push(s);
    }
    states.push(states[states.length - 1].sub(subkeys[0]));
    states.shift();
    return states;
}
function toVec(data) {
    const dataVec = [];
    for (let i = 0; i < data.length; ++i) {
        dataVec.push([data[i]]);
    }
    return dataVec;
}

/**
 * The Rescue-Prime hash function, as described in https://eprint.iacr.org/2020/1143.pdf.
 * Used with fixed m = 6 and capacity = 1 (rate = 5). According to Section 2.2, this offers log2(CURVE25519_BASE_FIELD.ORDER) / 2 bits of security against collision, preimage, and second-preimage attacks.
 * See the referenced paper for further details.
 */
class RescuePrimeHash {
    desc;
    rate;
    /**
     * Constructs a RescuePrimeHash instance with m = 6 and capacity = 1.
     */
    constructor() {
        this.desc = new RescueDesc(CURVE25519_BASE_FIELD, { kind: 'hash', m: 6, capacity: 1 });
        this.rate = 6 - 1;
    }
    // This is Algorithm 1 from https://eprint.iacr.org/2020/1143.pdf, though with the padding (see Algorithm 2).
    // The hash function outputs this.rate elements.
    /**
     * Computes the Rescue-Prime hash of a message, with padding as described in Algorithm 2 of the paper.
     * @param message - The input message as an array of bigints.
     * @returns The hash output as an array of bigints (length = rate).
     */
    digest(message) {
        message.push(1n);
        while (message.length % this.rate !== 0) {
            message.push(0n);
        }
        const zeros = [];
        for (let i = 0; i < this.desc.m; ++i) {
            zeros.push([0n]);
        }
        let state = new Matrix(this.desc.field, zeros);
        for (let r = 0; r < message.length / this.rate; ++r) {
            const data = [];
            for (let i = 0; i < this.rate; ++i) {
                data[i] = [message[r * this.rate + i]];
            }
            for (let i = this.rate; i < this.desc.m; ++i) {
                data[i] = [0n];
            }
            const s = new Matrix(this.desc.field, data);
            state = this.desc.permute(state.add(s, true));
        }
        const res = [];
        for (let i = 0; i < this.rate; ++i) {
            res.push(state.data[i][0]);
        }
        return res;
    }
}

/**
 * HMACRescuePrime provides a message authentication code (MAC) using the Rescue-Prime hash function.
 * We refer to https://datatracker.ietf.org/doc/html/rfc2104 for more details.
 */
class HMACRescuePrime {
    hasher;
    /**
     * Constructs a new HMACRescuePrime instance.
     */
    constructor() {
        this.hasher = new RescuePrimeHash();
    }
    /**
     * Computes the HMAC digest of a message with a given key using Rescue-Prime.
     * @param key - The key as an array of bigints.
     * @param message - The message as an array of bigints.
     * @returns The HMAC digest as an array of bigints.
     * @throws Error if the key is longer than the hash function's rate.
     */
    digest(key, message) {
        // We follow https://datatracker.ietf.org/doc/html/rfc2104, though since Rescue-Prime is not based
        // on the Merkle-Damgard construction we cannot have an exact anology between the
        // parameters. For our purpose, we set B = L = hasher.rate.
        if (key.length > this.hasher.rate) {
            throw Error(`length of key is supposed to be at most the hash function's rate (found ${key.length} and ${this.hasher.rate})`);
        }
        const ipad = deserializeLE(new Uint8Array(32).fill(0x36));
        const opad = deserializeLE(new Uint8Array(32).fill(0x5c));
        // the key is first extended to length B
        for (let i = 0; i < this.hasher.rate - key.length; ++i) {
            key.push(0n);
        }
        // inner padding
        const keyPlusIpad = key.map((k) => k + ipad);
        keyPlusIpad.push(...message);
        const innerDigest = this.hasher.digest(keyPlusIpad);
        // outer padding
        const keyPlusOpad = key.map((k) => k + opad);
        keyPlusOpad.push(...innerDigest);
        return this.hasher.digest(keyPlusOpad);
    }
}

/**
 * HKDF (HMAC-based Extract-and-Expand Key Derivation Function) using the Rescue-Prime hash function.
 * Follows RFC 5869. Only supports L = HashLen.
 */
class HKDFRescuePrime {
    hmac;
    /**
     * Constructs a new HKDFRescuePrime instance.
     */
    constructor() {
        this.hmac = new HMACRescuePrime();
    }
    /**
     * HKDF-Extract step: derives a pseudorandom key (PRK) from the input keying material (IKM) and salt.
     * @param salt - The salt value as an array of bigints.
     * @param ikm - The input keying material as an array of bigints.
     * @returns The pseudorandom key (PRK) as an array of bigints.
     */
    extract(salt, ikm) {
        if (salt.length === 0) {
            // HashLen = hasher.rate for Rescue-Prime
            for (let i = 0; i < this.hmac.hasher.rate; ++i) {
                salt.push(0n);
            }
        }
        return this.hmac.digest(salt, ikm);
    }
    /**
     * HKDF-Expand step: expands the pseudorandom key (PRK) with info to produce output keying material (OKM).
     * Only supports L = HashLen = 5, i.e. N = 1.
     * @param prk - The pseudorandom key as an array of bigints.
     * @param info - The context and application specific information as an array of bigints.
     * @returns The output keying material (OKM) as an array of bigints.
     */
    expand(prk, info) {
        // we only support L = HashLen = 5, i.e. N = 1
        // message = empty string | info | 0x01
        info.push(1n);
        return this.hmac.digest(prk, info);
    }
    /**
     * Performs the full HKDF (extract and expand) to derive output keying material (OKM).
     * @param salt - The salt value as an array of bigints.
     * @param ikm - The input keying material as an array of bigints.
     * @param info - The context and application specific information as an array of bigints.
     * @returns The output keying material (OKM) as an array of bigints.
     */
    okm(salt, ikm, info) {
        const prk = this.extract(salt, ikm);
        return this.expand(prk, info);
    }
}

/**
 * The Rescue cipher in Counter (CTR) mode, with a fixed block size m = 5.
 * See: https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287
 */
class RescueCipher {
    desc;
    /**
     * Constructs a RescueCipher instance using a shared secret.
     * The key is derived using HKDF-RescuePrime and used to initialize the RescueDesc.
     * @param sharedSecret - The shared secret to derive the cipher key from.
     */
    constructor(sharedSecret) {
        const hkdf = new HKDFRescuePrime();
        const rescueKey = hkdf.okm([], [deserializeLE(sharedSecret)], []);
        this.desc = new RescueDesc(CURVE25519_BASE_FIELD, { kind: 'cipher', key: rescueKey });
    }
    /**
     * Encrypts the plaintext vector in Counter (CTR) mode (raw, returns bigints).
     * @param plaintext - The array of plaintext bigints to encrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The ciphertext as an array of bigints.
     * @throws Error if the nonce is not 16 bytes long.
     */
    encrypt_raw(plaintext, nonce) {
        if (nonce.length !== 16) {
            throw Error(`nonce must be of length 16 (found ${nonce.length})`);
        }
        const binSize = getBinSize(this.desc.field.ORDER - 1n);
        function encryptBatch(desc, ptxt, cntr) {
            if (cntr.length !== 5) {
                throw Error(`counter must be of length 5 (found ${cntr.length})`);
            }
            const encryptedCounter = desc.permute(new Matrix(desc.field, toVec(cntr)));
            const ciphertext = [];
            for (let i = 0; i < ptxt.length; ++i) {
                if (!verifyBinSize(ptxt[i], binSize - 1n) || ctSignBit(ptxt[i], binSize) || !ctLt(ptxt[i], desc.field.ORDER, binSize)) {
                    throw Error(`plaintext must be non-negative and at most ${desc.field.ORDER}`);
                }
                const sum = ctAdd(ptxt[i], encryptedCounter.data[i][0], binSize);
                ciphertext.push(ctSelect(ctLt(sum, desc.field.ORDER, binSize), sum, ctSub(sum, desc.field.ORDER, binSize), binSize));
            }
            return ciphertext;
        }
        const nBlocks = Math.ceil(plaintext.length / 5);
        const counter = getCounter(deserializeLE(nonce), nBlocks);
        const ciphertext = [];
        for (let i = 0; i < nBlocks; ++i) {
            const cnt = 5 * i;
            const newCiphertext = encryptBatch(this.desc, plaintext.slice(cnt, Math.min(cnt + 5, plaintext.length)), counter.slice(cnt, cnt + 5));
            for (let j = 0; j < newCiphertext.length; ++j) {
                ciphertext.push(newCiphertext[j]);
            }
        }
        return ciphertext;
    }
    /**
     * Encrypts the plaintext vector in Counter (CTR) mode and serializes each block.
     * @param plaintext - The array of plaintext bigints to encrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The ciphertext as an array of arrays of numbers (each 32 bytes).
     */
    encrypt(plaintext, nonce) {
        return this.encrypt_raw(plaintext, nonce).map((c) => Array.from(serializeLE(c, 32)));
    }
    /**
     * Decrypts the ciphertext vector in Counter (CTR) mode (raw, expects bigints).
     * @param ciphertext - The array of ciphertext bigints to decrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The decrypted plaintext as an array of bigints.
     * @throws Error if the nonce is not 16 bytes long.
     */
    decrypt_raw(ciphertext, nonce) {
        if (nonce.length !== 16) {
            throw Error(`nonce must be of length 16 (found ${nonce.length})`);
        }
        const binSize = getBinSize(this.desc.field.ORDER - 1n);
        function decryptBatch(desc, ctxt, cntr) {
            if (cntr.length !== 5) {
                throw Error(`counter must be of length 5 (found ${cntr.length})`);
            }
            const encryptedCounter = desc.permute(new Matrix(desc.field, toVec(cntr)));
            const decrypted = [];
            for (let i = 0; i < ctxt.length; ++i) {
                const diff = ctSub(ctxt[i], encryptedCounter.data[i][0], binSize);
                decrypted.push(ctSelect(ctSignBit(diff, binSize), ctAdd(diff, desc.field.ORDER, binSize), diff, binSize));
            }
            return decrypted;
        }
        const nBlocks = Math.ceil(ciphertext.length / 5);
        const counter = getCounter(deserializeLE(nonce), nBlocks);
        const decrypted = [];
        for (let i = 0; i < nBlocks; ++i) {
            const cnt = 5 * i;
            const newDecrypted = decryptBatch(this.desc, ciphertext.slice(cnt, Math.min(cnt + 5, ciphertext.length)), counter.slice(cnt, cnt + 5));
            for (let j = 0; j < newDecrypted.length; ++j) {
                decrypted.push(newDecrypted[j]);
            }
        }
        return decrypted;
    }
    /**
     * Deserializes and decrypts the ciphertext vector in Counter (CTR) mode.
     * @param ciphertext - The array of arrays of numbers (each 32 bytes) to decrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The decrypted plaintext as an array of bigints.
     */
    decrypt(ciphertext, nonce) {
        return this.decrypt_raw(ciphertext.map((c) => {
            if (c.length !== 32) {
                throw Error(`ciphertext must be of length 32 (found ${c.length})`);
            }
            return deserializeLE(Uint8Array.from(c));
        }), nonce);
    }
}
/**
 * Generates the counter values for Rescue cipher CTR mode.
 * @param nonce - The initial nonce as a bigint.
 * @param nBlocks - The number of blocks to generate counters for.
 * @returns An array of counter values as bigints.
 */
function getCounter(nonce, nBlocks) {
    const counter = [];
    for (let i = 0n; i < nBlocks; ++i) {
        counter.push(nonce);
        counter.push(i);
        counter.push(0n);
        counter.push(0n);
        counter.push(0n);
    }
    return counter;
}

// The arcisEd25519 signature scheme. This is essentially ed25519 but we use the hash function
// SHA3-512 instead of SHA-512 since its multiplicative depth is much lower, which
// makes it much better suited to be evaluated in MPC.
// Those are the parameters specified [here](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1)
// (except for the hash function, see above). The below is copied from [here](https://github.com/paulmillr/noble-curves/blob/main/src/ed25519.ts#L111).
const arcisEd25519Defaults = (() => ({
    a: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819948'),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    Fp: ed25519.ed25519.CURVE.Fp,
    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
    h: BigInt(8),
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
    hash: sha3.sha3_512,
    randomBytes: utils.randomBytes,
    adjustScalarBytes,
    uvRatio,
}))();
/**
 * Clamps a 32-byte scalar as required by the Ed25519 signature scheme.
 * See: https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.5
 * @param bytes - The 32-byte scalar to clamp.
 * @returns The clamped scalar as a Uint8Array.
 */
function adjustScalarBytes(bytes) {
    const clamped = bytes;
    clamped[0] &= 248;
    clamped[31] &= 127;
    clamped[31] |= 64;
    return clamped;
}
/**
 * Dummy function for compatibility; not used in the ArcisEd25519 signature scheme.
 * Always returns { isValid: true, value: 0n }.
 * @returns An object with isValid: true and value: 0n.
 */
function uvRatio() {
    return { isValid: true, value: 0n };
}
/**
 * Ed25519 curve instance using SHA3-512 for hashing, suitable for MPC (ArcisEd25519 signature scheme).
 * This is essentially Ed25519 but with SHA3-512 instead of SHA-512 for lower multiplicative depth.
 * See: https://datatracker.ietf.org/doc/html/rfc8032#section-5.1
 */
const arcisEd25519 = (() => edwards.twistedEdwards(arcisEd25519Defaults))();

/**
 * AES-128 cipher in Counter (CTR) mode, using HKDF-SHA3-256 to derive the key from a shared secret.
 * See: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf (Section 6.5) for details on CTR mode.
 */
class Aes128Cipher {
    key;
    /**
     * Constructs an AES-128 cipher instance using a shared secret.
     * The key is derived using HKDF-SHA3-256.
     * @param sharedSecret - The shared secret to derive the AES key from.
     */
    constructor(sharedSecret) {
        const aesKey = crypto.hkdfSync('sha3-256', sharedSecret, new Uint8Array(), new Uint8Array(), 16);
        this.key = new Uint8Array(aesKey);
    }
    /**
     * Encrypts the plaintext array in Counter (CTR) mode.
     * @param plaintext - The data to encrypt.
     * @param nonce - An 8-byte nonce for CTR mode.
     * @returns The encrypted ciphertext as a Uint8Array.
     * @throws Error if the nonce is not 8 bytes long.
     */
    encrypt(plaintext, nonce) {
        if (nonce.length !== 8) {
            throw Error(`nonce must be of length 8 (found ${nonce.length})`);
        }
        const paddedNonce = Buffer.concat([nonce, Buffer.alloc(16 - nonce.length, 0)]);
        const cipher = crypto.createCipheriv('aes-128-ctr', this.key, paddedNonce);
        const ciphertext = Buffer.concat([cipher.update(plaintext), cipher.final()]);
        return new Uint8Array(ciphertext);
    }
    /**
     * Decrypts the ciphertext array in Counter (CTR) mode.
     * @param ciphertext - The data to decrypt.
     * @param nonce - An 8-byte nonce for CTR mode.
     * @returns The decrypted plaintext as a Uint8Array.
     * @throws Error if the nonce is not 8 bytes long.
     */
    decrypt(ciphertext, nonce) {
        if (nonce.length !== 8) {
            throw Error(`nonce must be of length 8 (found ${nonce.length})`);
        }
        const paddedNonce = Buffer.concat([nonce, Buffer.alloc(16 - nonce.length, 0)]);
        const cipher = crypto.createDecipheriv('aes-128-ctr', this.key, paddedNonce);
        const decrypted = Buffer.concat([cipher.update(ciphertext), cipher.final()]);
        return new Uint8Array(decrypted);
    }
}

/**
 * AES-192 cipher in Counter (CTR) mode, using HKDF-SHA3-256 to derive the key from a shared secret.
 * See: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf (Section 6.5) for details on CTR mode.
 */
class Aes192Cipher {
    key;
    /**
     * Constructs an AES-192 cipher instance using a shared secret.
     * The key is derived using HKDF-SHA3-256.
     * @param sharedSecret - The shared secret to derive the AES key from.
     */
    constructor(sharedSecret) {
        const aesKey = crypto.hkdfSync('sha3-256', sharedSecret, new Uint8Array(), new Uint8Array(), 24);
        this.key = new Uint8Array(aesKey);
    }
    /**
     * Encrypts the plaintext array in Counter (CTR) mode.
     * @param plaintext - The data to encrypt.
     * @param nonce - An 8-byte nonce for CTR mode.
     * @returns The encrypted ciphertext as a Uint8Array.
     * @throws Error if the nonce is not 8 bytes long.
     */
    encrypt(plaintext, nonce) {
        if (nonce.length !== 8) {
            throw Error(`nonce must be of length 8 (found ${nonce.length})`);
        }
        const paddedNonce = Buffer.concat([nonce, Buffer.alloc(16 - nonce.length, 0)]);
        const cipher = crypto.createCipheriv('aes-192-ctr', this.key, paddedNonce);
        const ciphertext = Buffer.concat([cipher.update(plaintext), cipher.final()]);
        return new Uint8Array(ciphertext);
    }
    /**
     * Decrypts the ciphertext array in Counter (CTR) mode.
     * @param ciphertext - The data to decrypt.
     * @param nonce - An 8-byte nonce for CTR mode.
     * @returns The decrypted plaintext as a Uint8Array.
     * @throws Error if the nonce is not 8 bytes long.
     */
    decrypt(ciphertext, nonce) {
        if (nonce.length !== 8) {
            throw Error(`nonce must be of length 8 (found ${nonce.length})`);
        }
        const paddedNonce = Buffer.concat([nonce, Buffer.alloc(16 - nonce.length, 0)]);
        const cipher = crypto.createDecipheriv('aes-192-ctr', this.key, paddedNonce);
        const decrypted = Buffer.concat([cipher.update(ciphertext), cipher.final()]);
        return new Uint8Array(decrypted);
    }
}

/**
 * AES-256 cipher in Counter (CTR) mode, using HKDF-SHA3-256 to derive the key from a shared secret.
 * See: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf (Section 6.5) for details on CTR mode.
 */
class Aes256Cipher {
    key;
    /**
     * Constructs an AES-256 cipher instance using a shared secret.
     * The key is derived using HKDF-SHA3-256.
     * @param sharedSecret - The shared secret to derive the AES key from.
     */
    constructor(sharedSecret) {
        const aesKey = crypto.hkdfSync('sha3-256', sharedSecret, new Uint8Array(), new Uint8Array(), 32);
        this.key = new Uint8Array(aesKey);
    }
    /**
     * Encrypts the plaintext array in Counter (CTR) mode.
     * @param plaintext - The data to encrypt.
     * @param nonce - An 8-byte nonce for CTR mode.
     * @returns The encrypted ciphertext as a Uint8Array.
     * @throws Error if the nonce is not 8 bytes long.
     */
    encrypt(plaintext, nonce) {
        if (nonce.length !== 8) {
            throw Error(`nonce must be of length 8 (found ${nonce.length})`);
        }
        const paddedNonce = Buffer.concat([nonce, Buffer.alloc(16 - nonce.length, 0)]);
        const cipher = crypto.createCipheriv('aes-256-ctr', this.key, paddedNonce);
        const ciphertext = Buffer.concat([cipher.update(plaintext), cipher.final()]);
        return new Uint8Array(ciphertext);
    }
    /**
     * Decrypts the ciphertext array in Counter (CTR) mode.
     * @param ciphertext - The data to decrypt.
     * @param nonce - An 8-byte nonce for CTR mode.
     * @returns The decrypted plaintext as a Uint8Array.
     * @throws Error if the nonce is not 8 bytes long.
     */
    decrypt(ciphertext, nonce) {
        if (nonce.length !== 8) {
            throw Error(`nonce must be of length 8 (found ${nonce.length})`);
        }
        const paddedNonce = Buffer.concat([nonce, Buffer.alloc(16 - nonce.length, 0)]);
        const cipher = crypto.createDecipheriv('aes-256-ctr', this.key, paddedNonce);
        const decrypted = Buffer.concat([cipher.update(ciphertext), cipher.final()]);
        return new Uint8Array(decrypted);
    }
}

var address = "BKck65TgoKRokMjQM3datB9oRwJ8rAj2jxPXvHXUvcL6";
var metadata = {
	name: "arcium",
	version: "0.3.0",
	spec: "0.1.0",
	description: "The Arcium program"
};
var instructions = [
	{
		name: "activate_arx",
		discriminator: [
			15,
			203,
			48,
			186,
			243,
			85,
			60,
			115
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "_node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			}
		]
	},
	{
		name: "activate_cluster",
		discriminator: [
			228,
			170,
			10,
			172,
			246,
			96,
			63,
			154
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			}
		]
	},
	{
		name: "bump_epoch_cluster",
		discriminator: [
			172,
			203,
			90,
			207,
			128,
			221,
			229,
			246
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_cluster_offset"
						}
					]
				}
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			}
		]
	},
	{
		name: "callback_computation",
		discriminator: [
			11,
			224,
			42,
			236,
			0,
			154,
			74,
			163
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "comp",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_def_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			},
			{
				name: "instructions_sysvar",
				address: "Sysvar1nstructions1111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "comp_def_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "execution_status",
				type: {
					defined: {
						name: "ExecutionStatus"
					}
				}
			}
		]
	},
	{
		name: "deactivate_arx",
		discriminator: [
			117,
			244,
			137,
			148,
			25,
			190,
			175,
			164
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "_node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "cluster_acc_0",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_1",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(1).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_2",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(2).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_3",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(3).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_4",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(4).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_5",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(5).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_6",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(6).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_7",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(7).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_8",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(8).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			},
			{
				name: "cluster_acc_9",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc.cluster_memberships.get(9).ok_or(ArciumError ::\nInvalidClusterMembership) ? ",
							account: "ArxNode"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			}
		]
	},
	{
		name: "deactivate_cluster",
		discriminator: [
			13,
			42,
			182,
			159,
			184,
			10,
			212,
			178
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "deactivation_epoch",
				type: {
					defined: {
						name: "Epoch"
					}
				}
			}
		]
	},
	{
		name: "dummy_instruction",
		docs: [
			"Only present so the mempool and execpool accounts are actually included in the idl, since we",
			"don't explicitly declare them in the accounts section of the other instructions."
		],
		discriminator: [
			57,
			4,
			200,
			151,
			58,
			19,
			120,
			9
		],
		accounts: [
			{
				name: "tiny_mempool"
			},
			{
				name: "tiny_execpool"
			},
			{
				name: "small_mempool"
			},
			{
				name: "small_execpool"
			},
			{
				name: "medium_mempool"
			},
			{
				name: "medium_execpool"
			},
			{
				name: "large_mempool"
			},
			{
				name: "large_execpool"
			}
		],
		args: [
		]
	},
	{
		name: "embiggen_raw_circuit_acc",
		discriminator: [
			92,
			195,
			192,
			21,
			193,
			242,
			135,
			194
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			},
			{
				name: "comp_def_raw",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								82,
								97,
								119
							]
						},
						{
							kind: "account",
							path: "comp_def_acc"
						},
						{
							kind: "arg",
							path: "_raw_circuit_index"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "raw_circuit_index",
				type: "u8"
			}
		]
	},
	{
		name: "finalize_computation",
		discriminator: [
			43,
			29,
			152,
			92,
			241,
			179,
			193,
			210
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_def_offset"
						}
					]
				}
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "comp_def_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "finalize_computation_definition",
		discriminator: [
			174,
			66,
			159,
			51,
			199,
			243,
			219,
			38
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp_def_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "finalize_mxe_keys",
		discriminator: [
			108,
			137,
			125,
			95,
			202,
			237,
			190,
			158
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "_mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "increase_mempool_size",
		discriminator: [
			19,
			165,
			166,
			25,
			174,
			122,
			166,
			250
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_program"
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
		]
	},
	{
		name: "init",
		discriminator: [
			220,
			59,
			207,
			236,
			108,
			250,
			47,
			100
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "fee_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "start_epoch_timestamp",
				type: {
					defined: {
						name: "Timestamp"
					}
				}
			}
		]
	},
	{
		name: "init_arx_node",
		discriminator: [
			55,
			177,
			212,
			125,
			72,
			118,
			148,
			232
		],
		accounts: [
			{
				name: "operator_signer",
				writable: true,
				signer: true
			},
			{
				name: "operator_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								79,
								112,
								101,
								114,
								97,
								116,
								111,
								114
							]
						},
						{
							kind: "account",
							path: "operator_signer"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "config",
				type: {
					defined: {
						name: "ArxNodeConfig"
					}
				}
			},
			{
				name: "cu_capacity_claim",
				type: "u64"
			},
			{
				name: "metadata",
				type: {
					defined: {
						name: "NodeMetadata"
					}
				}
			}
		]
	},
	{
		name: "init_cluster",
		discriminator: [
			144,
			230,
			5,
			18,
			93,
			71,
			133,
			187
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "authority"
			},
			{
				name: "pool_account",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "max_size",
				type: "u32"
			},
			{
				name: "cu_price",
				type: "u64"
			}
		]
	},
	{
		name: "init_computation_definition",
		docs: [
			"Initializes a computation definition."
		],
		discriminator: [
			45,
			185,
			155,
			17,
			97,
			77,
			230,
			73
		],
		accounts: [
			{
				name: "signer",
				docs: [
					"Signer of the transaction."
				],
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "comp_def_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				docs: [
					"System program account."
				],
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "computation_definition",
				type: {
					defined: {
						name: "ComputationDefinitionMeta"
					}
				}
			},
			{
				name: "circuit_source_override",
				type: {
					option: {
						defined: {
							name: "CircuitSource"
						}
					}
				}
			},
			{
				name: "cu_amount",
				type: "u64"
			},
			{
				name: "finalization_authority",
				type: {
					option: "pubkey"
				}
			},
			{
				name: "finalize_during_callback",
				type: "bool"
			}
		]
	},
	{
		name: "init_mxe",
		docs: [
			"Initializes a MPC Execution Environment."
		],
		discriminator: [
			240,
			227,
			11,
			166,
			193,
			167,
			25,
			79
		],
		accounts: [
			{
				name: "signer",
				docs: [
					"Signer of the transaction."
				],
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				docs: [
					"MXE account to initialize."
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "mempool",
				docs: [
					"function"
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "execpool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "cluster",
				docs: [
					"Cluster to add to the MXE."
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mxe_keygen_computation_definition",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						},
						{
							kind: "const",
							value: [
								1,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "mxe_keygen_computation",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						},
						{
							kind: "const",
							value: [
								1,
								0,
								0,
								0,
								0,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "mxe_authority",
				optional: true
			},
			{
				name: "mxe_program",
				docs: [
					"constraint in tests because setting it would require us to deploy a program each time."
				]
			},
			{
				name: "system_program",
				docs: [
					"System program account."
				],
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "mempool_size",
				type: {
					defined: {
						name: "MempoolSize"
					}
				}
			}
		]
	},
	{
		name: "init_operator",
		discriminator: [
			132,
			210,
			12,
			91,
			159,
			94,
			35,
			54
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "operator_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								79,
								112,
								101,
								114,
								97,
								116,
								111,
								114
							]
						},
						{
							kind: "account",
							path: "signer"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "meta",
				type: {
					defined: {
						name: "OperatorMeta"
					}
				}
			}
		]
	},
	{
		name: "init_raw_circuit_acc",
		discriminator: [
			16,
			228,
			193,
			228,
			93,
			231,
			58,
			4
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			},
			{
				name: "comp_def_raw",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								82,
								97,
								119
							]
						},
						{
							kind: "account",
							path: "comp_def_acc"
						},
						{
							kind: "arg",
							path: "_raw_circuit_index"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "raw_circuit_index",
				type: "u8"
			}
		]
	},
	{
		name: "join_cluster",
		discriminator: [
			150,
			167,
			124,
			239,
			108,
			128,
			31,
			162
		],
		accounts: [
			{
				name: "node_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "node_bump",
				type: "u32"
			},
			{
				name: "join",
				type: "bool"
			}
		]
	},
	{
		name: "leave_mxe",
		discriminator: [
			225,
			222,
			68,
			9,
			96,
			160,
			126,
			211
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "propose_fee",
		discriminator: [
			103,
			204,
			172,
			134,
			248,
			252,
			27,
			170
		],
		accounts: [
			{
				name: "node_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "proposed_fee",
				type: "u64"
			}
		]
	},
	{
		name: "propose_join_cluster",
		discriminator: [
			148,
			228,
			222,
			211,
			161,
			128,
			118,
			175
		],
		accounts: [
			{
				name: "cluster_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "node_bump",
				type: "u32"
			}
		]
	},
	{
		name: "queue_computation",
		docs: [
			"Queues a computation.",
			"cu_price_micro: The priority price of a CU, in thousandths of a $ARX. Used",
			"to calculate the priority fee and rounded down."
		],
		discriminator: [
			1,
			149,
			103,
			13,
			102,
			227,
			93,
			164
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "sign_seed",
				docs: [
					"This is ok-ish though, as we're not reading the account, we just need it to check that the",
					"CPI invocation is valid. The only downside is it's a bit ugly and wastes some CUs since",
					"we can't use a potentially stored bump."
				],
				signer: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								83,
								105,
								103,
								110,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					],
					program: {
						kind: "arg",
						path: "_mxe_program"
					}
				}
			},
			{
				name: "comp",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "computation_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "computation_definition_offset"
						}
					]
				}
			},
			{
				name: "cluster",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_index.map_or(mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? , | i |\nmxe.fallback_clusters [i as usize])"
						}
					]
				}
			},
			{
				name: "pool_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			},
			{
				name: "clock",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "computation_definition_offset",
				type: "u32"
			},
			{
				name: "cluster_index",
				type: {
					option: "u16"
				}
			},
			{
				name: "args",
				type: {
					vec: {
						defined: {
							name: "Argument"
						}
					}
				}
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "callback_url",
				type: {
					option: "string"
				}
			},
			{
				name: "custom_callback_instructions",
				type: {
					vec: {
						defined: {
							name: "CallbackInstruction"
						}
					}
				}
			},
			{
				name: "input_delivery_fee",
				type: "u64"
			},
			{
				name: "output_delivery_fee",
				type: "u64"
			},
			{
				name: "cu_price_micro",
				type: "u64"
			}
		]
	},
	{
		name: "set_arx_node_config",
		discriminator: [
			163,
			75,
			176,
			148,
			145,
			196,
			238,
			234
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "_node_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "config",
				type: {
					defined: {
						name: "ArxNodeConfig"
					}
				}
			}
		]
	},
	{
		name: "set_arx_node_metadata",
		discriminator: [
			176,
			88,
			44,
			90,
			127,
			151,
			62,
			80
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "_node_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "meta",
				type: {
					defined: {
						name: "NodeMetadata"
					}
				}
			}
		]
	},
	{
		name: "set_cluster",
		discriminator: [
			140,
			96,
			38,
			83,
			225,
			128,
			25,
			176
		],
		accounts: [
			{
				name: "signer",
				docs: [
					"Signer of the transaction."
				],
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				docs: [
					"MXE account to set the cluster for."
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "cluster",
				docs: [
					"Cluster to set for the MXE."
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mxe_program"
			},
			{
				name: "system_program",
				docs: [
					"System program account."
				],
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			}
		]
	},
	{
		name: "set_cluster_authority",
		discriminator: [
			94,
			172,
			32,
			75,
			38,
			40,
			31,
			106
		],
		accounts: [
			{
				name: "current_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "new_authority",
				type: {
					option: "pubkey"
				}
			}
		]
	},
	{
		name: "set_mxe_keys",
		discriminator: [
			156,
			205,
			125,
			215,
			134,
			88,
			62,
			144
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "_mxe_program",
				type: "pubkey"
			},
			{
				name: "mxe_x25519_pubkey",
				type: {
					array: [
						"u8",
						32
					]
				}
			}
		]
	},
	{
		name: "update_current_epoch_idempotent",
		discriminator: [
			47,
			73,
			68,
			127,
			116,
			74,
			89,
			62
		],
		accounts: [
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
		]
	},
	{
		name: "upload_circuit",
		discriminator: [
			86,
			238,
			214,
			111,
			30,
			23,
			168,
			100
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			},
			{
				name: "comp_def_raw",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								82,
								97,
								119
							]
						},
						{
							kind: "account",
							path: "comp_def_acc"
						},
						{
							kind: "arg",
							path: "raw_circuit_index"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "raw_circuit_index",
				type: "u8"
			},
			{
				name: "upload_data",
				type: {
					array: [
						"u8",
						814
					]
				}
			},
			{
				name: "offset",
				type: "u32"
			}
		]
	},
	{
		name: "vote_fee",
		discriminator: [
			39,
			118,
			79,
			185,
			118,
			12,
			71,
			84
		],
		accounts: [
			{
				name: "node_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "fee_vote",
				type: "u64"
			}
		]
	}
];
var accounts = [
	{
		name: "ArxNode",
		discriminator: [
			2,
			207,
			122,
			223,
			93,
			97,
			231,
			199
		]
	},
	{
		name: "ClockAccount",
		discriminator: [
			152,
			171,
			158,
			195,
			75,
			61,
			51,
			8
		]
	},
	{
		name: "Cluster",
		discriminator: [
			236,
			225,
			118,
			228,
			173,
			106,
			18,
			60
		]
	},
	{
		name: "ComputationAccount",
		discriminator: [
			136,
			34,
			167,
			71,
			41,
			174,
			103,
			77
		]
	},
	{
		name: "ComputationDefinitionAccount",
		discriminator: [
			245,
			176,
			217,
			221,
			253,
			104,
			172,
			200
		]
	},
	{
		name: "ComputationDefinitionRaw",
		discriminator: [
			226,
			70,
			57,
			224,
			38,
			233,
			59,
			136
		]
	},
	{
		name: "FeePool",
		discriminator: [
			172,
			38,
			77,
			146,
			148,
			5,
			51,
			242
		]
	},
	{
		name: "LargeExecPool",
		discriminator: [
			147,
			145,
			148,
			170,
			30,
			13,
			43,
			216
		]
	},
	{
		name: "LargeMempool",
		discriminator: [
			16,
			168,
			90,
			235,
			249,
			207,
			73,
			223
		]
	},
	{
		name: "MXEAccount",
		discriminator: [
			103,
			26,
			85,
			250,
			179,
			159,
			17,
			117
		]
	},
	{
		name: "MediumExecPool",
		discriminator: [
			97,
			117,
			128,
			202,
			213,
			76,
			5,
			163
		]
	},
	{
		name: "MediumMempool",
		discriminator: [
			10,
			249,
			58,
			39,
			255,
			231,
			199,
			168
		]
	},
	{
		name: "Operator",
		discriminator: [
			219,
			31,
			188,
			145,
			69,
			139,
			204,
			117
		]
	},
	{
		name: "SmallExecPool",
		discriminator: [
			37,
			147,
			249,
			253,
			217,
			136,
			3,
			87
		]
	},
	{
		name: "SmallMempool",
		discriminator: [
			123,
			153,
			151,
			118,
			126,
			71,
			73,
			92
		]
	},
	{
		name: "TinyExecPool",
		discriminator: [
			80,
			245,
			5,
			90,
			154,
			189,
			190,
			172
		]
	},
	{
		name: "TinyMempool",
		discriminator: [
			176,
			33,
			67,
			108,
			73,
			135,
			110,
			166
		]
	}
];
var events = [
	{
		name: "CallbackComputationEvent",
		discriminator: [
			155,
			213,
			238,
			159,
			240,
			76,
			167,
			19
		]
	},
	{
		name: "FinalizeComputationEvent",
		discriminator: [
			27,
			75,
			117,
			221,
			191,
			213,
			253,
			249
		]
	},
	{
		name: "InitComputationEvent",
		discriminator: [
			17,
			51,
			124,
			226,
			70,
			97,
			58,
			186
		]
	},
	{
		name: "QueueComputationEvent",
		discriminator: [
			118,
			53,
			33,
			169,
			32,
			14,
			197,
			147
		]
	}
];
var errors = [
	{
		code: 6000,
		name: "InvalidAuthority",
		msg: "The given authority is invalid"
	},
	{
		code: 6001,
		name: "MxeKeysAlreadySet",
		msg: "The MXE keys are already set, i.e. all the nodes of the MXE cluster already agreed on the MXE keys"
	},
	{
		code: 6002,
		name: "MxeKeysNotSet",
		msg: "The MXE keys are not set, i.e. not all the nodes of the MXE cluster agreed on the MXE keys"
	},
	{
		code: 6003,
		name: "InvalidMXE",
		msg: "An invalid MXE account has been supplied"
	},
	{
		code: 6004,
		name: "ClusterAlreadySet",
		msg: "The cluster is already set"
	},
	{
		code: 6005,
		name: "ClusterNotSet",
		msg: "The cluster is not set"
	},
	{
		code: 6006,
		name: "InvalidCluster",
		msg: "An invalid cluster account has been supplied"
	},
	{
		code: 6007,
		name: "InvalidComputationDefinition",
		msg: "An invalid computation definition account has been supplied"
	},
	{
		code: 6008,
		name: "CantFindMempoolID",
		msg: "Couldn't find a mempool ID for the computation"
	},
	{
		code: 6100,
		name: "InvalidMempoolDiscriminator",
		msg: "Mempool discriminator is invalid"
	},
	{
		code: 6101,
		name: "InvalidMempoolSize",
		msg: "Mempool size is invalid"
	},
	{
		code: 6102,
		name: "InvalidExecpoolDiscriminator",
		msg: "Execpool discriminator is invalid"
	},
	{
		code: 6103,
		name: "MaxParallelismReached",
		msg: "Max parallelism reached"
	},
	{
		code: 6200,
		name: "InvalidComputationOffset",
		msg: "Computation offset is invalid"
	},
	{
		code: 6201,
		name: "InvalidCallbackAccs",
		msg: "Callback accounts are invalid"
	},
	{
		code: 6202,
		name: "InvalidCallbackAccsLen",
		msg: "Callback accounts length is invalid"
	},
	{
		code: 6203,
		name: "AlreadyInitializedComputation",
		msg: "The computation is already initialized"
	},
	{
		code: 6204,
		name: "AlreadyCallbackedComputation",
		msg: "Callback computation already called"
	},
	{
		code: 6205,
		name: "InvalidFinalizeTx",
		msg: "Finalize tx is invalid"
	},
	{
		code: 6206,
		name: "InvalidComputationStatus",
		msg: "Computation status is invalid"
	},
	{
		code: 6207,
		name: "InvalidComputation",
		msg: "Computation is invalid"
	},
	{
		code: 6208,
		name: "InvalidComputationAuthority",
		msg: "Computation authority is invalid"
	},
	{
		code: 6209,
		name: "InvalidCallbackInstructions",
		msg: "Callback instructions are invalid"
	},
	{
		code: 6300,
		name: "ComputationDefinitionNotCompleted",
		msg: "Computation definition is not completed"
	},
	{
		code: 6301,
		name: "InvalidArguments",
		msg: "Arguments supplied are invalid"
	},
	{
		code: 6302,
		name: "InvalidCircuitSource",
		msg: "Circuit source is invalid"
	},
	{
		code: 6303,
		name: "ComputationDefinitionAlreadyCompleted",
		msg: "Computation definition already completed"
	},
	{
		code: 6400,
		name: "InvalidNode",
		msg: "Node is invalid"
	},
	{
		code: 6401,
		name: "MaxClusterMembershipReached",
		msg: "Maximum number of nodes in the cluster has been reached"
	},
	{
		code: 6402,
		name: "NodeAlreadyExists",
		msg: "The node already exists in the cluster"
	},
	{
		code: 6403,
		name: "InvalidNodeAuthority",
		msg: "Node authority is invalid"
	},
	{
		code: 6404,
		name: "NodeNotInactive",
		msg: "Node is not inactive"
	},
	{
		code: 6405,
		name: "NodeNotActive",
		msg: "Node is not active"
	},
	{
		code: 6406,
		name: "InvalidClusterMembership",
		msg: "Cluster membership is invalid"
	},
	{
		code: 6407,
		name: "NodeInActiveCluster",
		msg: "Node is in an active cluster"
	},
	{
		code: 6408,
		name: "InvalidNodeConfig",
		msg: "Node config is invalid"
	},
	{
		code: 6500,
		name: "ClusterFull",
		msg: "Cluster is full"
	},
	{
		code: 6501,
		name: "InvalidDeactivationEpoch",
		msg: "Cluster deactivation epoch is invalid"
	},
	{
		code: 6502,
		name: "InvalidMaxSize",
		msg: "Cluster maximum size is invalid"
	},
	{
		code: 6503,
		name: "InvalidClusterAuthority",
		msg: "Cluster authority is invalid"
	},
	{
		code: 6504,
		name: "InvalidFeeProposal",
		msg: "Cluster fee proposal is invalid"
	},
	{
		code: 6505,
		name: "InvalidClusterState",
		msg: "Cluster state is invalid"
	},
	{
		code: 6506,
		name: "InvalidVote",
		msg: "Cluster vote is invalid"
	},
	{
		code: 6600,
		name: "SerializationFailed",
		msg: "Borsh serialization failed"
	},
	{
		code: 6601,
		name: "DeserializationFailed",
		msg: "Borsh deserialization failed"
	},
	{
		code: 6602,
		name: "HeapFull",
		msg: "Heap is full"
	},
	{
		code: 6603,
		name: "InvalidSlot",
		msg: "Current slot is before the last updated slot"
	},
	{
		code: 6604,
		name: "EpochIsInfinity",
		msg: "Epoch is infinity"
	},
	{
		code: 6605,
		name: "InvalidTimestamp",
		msg: "Timestamp is invalid"
	},
	{
		code: 6606,
		name: "InvalidEpoch",
		msg: "Epoch is invalid"
	},
	{
		code: 6607,
		name: "EpochOverflow",
		msg: "Epoch overflowed"
	}
];
var types = [
	{
		name: "AbortReason",
		type: {
			kind: "enum",
			variants: [
				{
					name: "InvalidMAC"
				},
				{
					name: "ExpectedSentShare"
				},
				{
					name: "ExpectedFieldElement"
				},
				{
					name: "ExpectedAbort"
				},
				{
					name: "MalformedData"
				},
				{
					name: "ComputationFailed"
				},
				{
					name: "InternalError"
				},
				{
					name: "PreprocessingStreamError"
				},
				{
					name: "DivisionByZero"
				},
				{
					name: "NoSignature"
				},
				{
					name: "InvalidSignature"
				},
				{
					name: "PrimitiveError"
				},
				{
					name: "QuadraticNonResidue"
				}
			]
		}
	},
	{
		name: "AcccountAccessInfo",
		serialization: "bytemuck",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: "u16"
				}
			]
		}
	},
	{
		name: "Activation",
		type: {
			kind: "struct",
			fields: [
				{
					name: "activation_epoch",
					docs: [
						"epoch for the cluster was activated. Epoch::INFINITY if inactive."
					],
					type: {
						defined: {
							name: "Epoch"
						}
					}
				},
				{
					name: "deactivation_epoch",
					docs: [
						"epoch for the cluster to be deactivated. Epoch::INFINITY if none."
					],
					type: {
						defined: {
							name: "Epoch"
						}
					}
				}
			]
		}
	},
	{
		name: "Argument",
		docs: [
			"An argument passed into a [Computation], corresponding to [super::mxe::Parameter] of the",
			"[super::mxe::ComputationSignature]. An argument that corresponds to a Parameter type."
		],
		type: {
			kind: "enum",
			variants: [
				{
					name: "PlaintextBool",
					fields: [
						"bool"
					]
				},
				{
					name: "PlaintextU8",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextU16",
					fields: [
						"u16"
					]
				},
				{
					name: "PlaintextU32",
					fields: [
						"u32"
					]
				},
				{
					name: "PlaintextU64",
					fields: [
						"u64"
					]
				},
				{
					name: "PlaintextU128",
					fields: [
						"u128"
					]
				},
				{
					name: "PlaintextFloat",
					fields: [
						"f64"
					]
				},
				{
					name: "EncryptedBool",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "EncryptedU8",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "EncryptedU16",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "EncryptedU32",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "EncryptedU64",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "EncryptedU128",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "EncryptedFloat",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "ArcisPubkey",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "ArcisSignature",
					fields: [
						{
							array: [
								"u8",
								64
							]
						}
					]
				},
				{
					name: "Account",
					fields: [
						"pubkey",
						"u32",
						"u32"
					]
				},
				{
					name: "ManticoreAlgo",
					fields: [
						"string"
					]
				},
				{
					name: "InputDataset",
					fields: [
						"string"
					]
				}
			]
		}
	},
	{
		name: "ArxNode",
		type: {
			kind: "struct",
			fields: [
				{
					name: "primary_staking_account",
					type: "pubkey"
				},
				{
					name: "metadata",
					type: {
						defined: {
							name: "NodeMetadata"
						}
					}
				},
				{
					name: "config",
					type: {
						defined: {
							name: "ArxNodeConfig"
						}
					}
				},
				{
					name: "cluster_memberships",
					docs: [
						"The offsets of the cluster the node is a member of."
					],
					type: {
						vec: "u32"
					}
				},
				{
					name: "proposed_cluster_memberships",
					docs: [
						"The offsets of the clusters the node has been proposed to be a member of."
					],
					type: {
						vec: "u32"
					}
				},
				{
					name: "cu_capacity_claim",
					type: "u64"
				},
				{
					name: "is_active",
					type: "bool"
				},
				{
					name: "reserved",
					type: {
						array: [
							"u8",
							32
						]
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "ArxNodeConfig",
		type: {
			kind: "struct",
			fields: [
				{
					name: "max_cluster_memberships",
					type: "u32"
				},
				{
					name: "authority",
					docs: [
						"Admin key for node management operations"
					],
					type: "pubkey"
				},
				{
					name: "callback_authority",
					docs: [
						"Key used to sign computation callbacks - separated for operational security"
					],
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "CallbackAccount",
		docs: [
			"A callback account to be provided to a computation.",
			"We don't specify signer, since node operators can't sign."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "pubkey",
					type: "pubkey"
				},
				{
					name: "is_writable",
					type: "bool"
				}
			]
		}
	},
	{
		name: "CallbackComputationEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "CallbackInstruction",
		docs: [
			"A custom callback instruction with its own program ID and discriminator."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "program_id",
					type: "pubkey"
				},
				{
					name: "discriminator",
					type: "bytes"
				},
				{
					name: "accounts",
					type: {
						vec: {
							defined: {
								name: "CallbackAccount"
							}
						}
					}
				}
			]
		}
	},
	{
		name: "CircuitSource",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Local",
					fields: [
						{
							defined: {
								name: "LocalCircuitSource"
							}
						}
					]
				},
				{
					name: "OnChain",
					fields: [
						{
							defined: {
								name: "OnChainCircuitSource"
							}
						}
					]
				},
				{
					name: "OffChain",
					fields: [
						{
							defined: {
								name: "OffChainCircuitSource"
							}
						}
					]
				}
			]
		}
	},
	{
		name: "ClockAccount",
		docs: [
			"An account storing the current network epoch"
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "start_epoch",
					type: {
						defined: {
							name: "Epoch"
						}
					}
				},
				{
					name: "current_epoch",
					type: {
						defined: {
							name: "Epoch"
						}
					}
				},
				{
					name: "start_epoch_timestamp",
					type: {
						defined: {
							name: "Timestamp"
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "Cluster",
		type: {
			kind: "struct",
			fields: [
				{
					name: "authority",
					type: {
						option: "pubkey"
					}
				},
				{
					name: "max_size",
					type: "u32"
				},
				{
					name: "activation",
					type: {
						defined: {
							name: "Activation"
						}
					}
				},
				{
					name: "max_capacity",
					type: "u64"
				},
				{
					name: "cu_price",
					docs: [
						"The price of compute units in this cluster."
					],
					type: "u64"
				},
				{
					name: "cu_price_proposals",
					docs: [
						"The proposals for the cu price proposals in the next epoch.",
						"Index 0 is always the current price, we allow `MAX_FEE_PROPS` at most."
					],
					type: {
						array: [
							"u64",
							32
						]
					}
				},
				{
					name: "last_updated_epoch",
					docs: [
						"The epoch this cluster was last updated.",
						"Used to determine if the cluster needs to be updated."
					],
					type: {
						defined: {
							name: "Epoch"
						}
					}
				},
				{
					name: "mxes",
					docs: [
						"The MXE's that this cluster is assigned to. Referred to by the MXE's program id."
					],
					type: {
						vec: "pubkey"
					}
				},
				{
					name: "nodes",
					type: {
						vec: {
							defined: {
								name: "NodeRef"
							}
						}
					}
				},
				{
					name: "pending_nodes",
					type: {
						vec: {
							defined: {
								name: "NodeRef"
							}
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "ComputationAccount",
		docs: [
			"A computation execution call to a [super::mxe::ComputationDefinitionAccount]."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "payer",
					type: "pubkey"
				},
				{
					name: "cluster_index",
					docs: [
						"The MXE's cluster to be used for execution.",
						"",
						"# Notes",
						"",
						"- [None] represents the default cluster,",
						"- [Some] specifies the index of the fallback cluster."
					],
					type: {
						option: "u16"
					}
				},
				{
					name: "computation_definition_offset",
					docs: [
						"The offset of the corresponding [super::mxe::ComputationDefinitionAccount]."
					],
					type: "u32"
				},
				{
					name: "execution_fee",
					docs: [
						"The execution fee for the execution."
					],
					type: {
						defined: {
							name: "ExecutionFee"
						}
					}
				},
				{
					name: "slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "status",
					type: {
						defined: {
							name: "ComputationStatus"
						}
					}
				},
				{
					name: "arguments",
					docs: [
						"The arguments passed to the computation. If it is a manticore computation, we expect the",
						"first element to be of type ManticoreAlgo"
					],
					type: {
						vec: {
							defined: {
								name: "Argument"
							}
						}
					}
				},
				{
					name: "callback_url",
					type: {
						option: "string"
					}
				},
				{
					name: "custom_callback_instructions",
					type: {
						vec: {
							defined: {
								name: "CallbackInstruction"
							}
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "ComputationDefinitionAccount",
		docs: [
			"An account representing a [ComputationDefinition] in a MXE."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "finalization_authority",
					docs: [
						"The authority that is allowed to finalize the computation. If set to None, anyone can."
					],
					type: {
						option: "pubkey"
					}
				},
				{
					name: "finalize_during_callback",
					docs: [
						"Whether to we need a separate callback and finalize instruction or if we can do it in one."
					],
					type: "bool"
				},
				{
					name: "cu_amount",
					docs: [
						"The amount of CUs this computation will use."
					],
					type: "u64"
				},
				{
					name: "definition",
					docs: [
						"The interface of the computation to execute."
					],
					type: {
						defined: {
							name: "ComputationDefinitionMeta"
						}
					}
				},
				{
					name: "circuit_source",
					docs: [
						"Where to fetch the actual raw circuit to execute."
					],
					type: {
						defined: {
							name: "CircuitSource"
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "ComputationDefinitionMeta",
		docs: [
			"A computation definition for execution in a MXE."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "circuit_len",
					type: "u32"
				},
				{
					name: "signature",
					type: {
						defined: {
							name: "ComputationSignature"
						}
					}
				}
			]
		}
	},
	{
		name: "ComputationDefinitionRaw",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "compiled_circuit",
					docs: [
						"The length here is meaningless."
					],
					type: {
						array: [
							"u8",
							0
						]
					}
				}
			]
		}
	},
	{
		name: "ComputationReference",
		serialization: "bytemuck",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "priority_fee",
					type: "u64"
				},
				{
					name: "computation_definition_offset",
					type: "u32"
				},
				{
					name: "accs",
					type: {
						array: [
							{
								defined: {
									name: "AcccountAccessInfo"
								}
							},
							10
						]
					}
				}
			]
		}
	},
	{
		name: "ComputationSignature",
		docs: [
			"The signature of a computation defined in a [ComputationDefinition]."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "parameters",
					docs: [
						"The input parameters of the computation."
					],
					type: {
						vec: {
							defined: {
								name: "Parameter"
							}
						}
					}
				},
				{
					name: "outputs",
					docs: [
						"The output(s) of the computation."
					],
					type: {
						vec: {
							defined: {
								name: "Output"
							}
						}
					}
				}
			]
		}
	},
	{
		name: "ComputationStatus",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Queued"
				},
				{
					name: "Executed"
				},
				{
					name: "Finalized"
				}
			]
		}
	},
	{
		name: "Epoch",
		docs: [
			"The network epoch"
		],
		type: {
			kind: "struct",
			fields: [
				"u64"
			]
		}
	},
	{
		name: "ExecutingPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		generics: [
			{
				kind: "const",
				name: "MAX_PARRALLEL_COMPUTATIONS",
				type: "usize"
			}
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "comp_status",
					type: {
						array: [
							"u8",
							13
						]
					}
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							2
						]
					}
				},
				{
					name: "counter",
					type: "u64"
				},
				{
					name: "execpool_index",
					type: {
						array: [
							"u64",
							{
								generic: "MAX_PARRALLEL_COMPUTATIONS"
							}
						]
					}
				},
				{
					name: "currently_executing",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							{
								generic: "MAX_PARRALLEL_COMPUTATIONS"
							}
						]
					}
				}
			]
		}
	},
	{
		name: "ExecutionFailure",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Serialization"
				},
				{
					name: "Router"
				},
				{
					name: "Circuit"
				},
				{
					name: "Inputs"
				},
				{
					name: "ProtocolInit"
				},
				{
					name: "ProtocolRun"
				},
				{
					name: "Abort",
					fields: [
						{
							defined: {
								name: "AbortReason"
							}
						}
					]
				}
			]
		}
	},
	{
		name: "ExecutionFee",
		type: {
			kind: "struct",
			fields: [
				{
					name: "base_fee",
					docs: [
						"The base fee for the computation."
					],
					type: "u64"
				},
				{
					name: "priority_fee",
					docs: [
						"The additional fee to enforce priortized execution in the mempool."
					],
					type: "u64"
				},
				{
					name: "input_delivery_fee",
					docs: [
						"A fee for data relaying used with [super::mxe::DataProvisioning::Protected] data",
						"provisioning."
					],
					type: "u64"
				},
				{
					name: "output_delivery_fee",
					docs: [
						"A fee for relayer based (unverifiable) off-chain output delivery."
					],
					type: "u64"
				}
			]
		}
	},
	{
		name: "ExecutionStatus",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Success"
				},
				{
					name: "Failure",
					fields: [
						{
							defined: {
								name: "ExecutionFailure"
							}
						},
						{
							array: [
								"u8",
								32
							]
						}
					]
				}
			]
		}
	},
	{
		name: "FeePool",
		type: {
			kind: "struct",
			fields: [
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "FinalizeComputationEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "InitComputationEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "LargeExecPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "ExecutingPool",
							generics: [
								{
									kind: "const",
									value: "100"
								}
							]
						}
					}
				}
			]
		}
	},
	{
		name: "LargeMempool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "LargeMempoolInner"
						}
					}
				}
			]
		}
	},
	{
		name: "LargeMempoolInner",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "last_updated_slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							5
						]
					}
				},
				{
					name: "computations",
					type: {
						defined: {
							name: "LargeMempoolInnerBuffer"
						}
					}
				}
			]
		}
	},
	{
		name: "LargeMempoolInnerBuffer",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "elems",
					type: {
						array: [
							{
								defined: {
									name: "LargeMempoolInnerBufferHeap"
								}
							},
							180
						]
					}
				},
				{
					name: "valid_bits",
					docs: [
						"Bit array tracking which slots are valid (1 = valid, 0 = stale)",
						"1 bit per slot, packed into bytes. For $buffer_length=180, this is 23 bytes."
					],
					type: {
						array: [
							"u8",
							23
						]
					}
				},
				{
					name: "start_index",
					type: "u8"
				},
				{
					name: "length",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				}
			]
		}
	},
	{
		name: "LargeMempoolInnerBufferHeap",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "entries",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							100
						]
					}
				},
				{
					name: "count",
					type: "u16"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				}
			]
		}
	},
	{
		name: "LocalCircuitSource",
		type: {
			kind: "enum",
			variants: [
				{
					name: "MxeKeygen"
				}
			]
		}
	},
	{
		name: "MXEAccount",
		docs: [
			"A MPC Execution Environment."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "authority",
					docs: [
						"The management authority of the MXE."
					],
					type: {
						option: "pubkey"
					}
				},
				{
					name: "cluster",
					docs: [
						"The cluster executing the MXE."
					],
					type: {
						option: "u32"
					}
				},
				{
					name: "x25519_pubkey",
					docs: [
						"The x25519 pubkey (256 bits curve25519), used for encrypted data."
					],
					type: {
						defined: {
							name: "X25519Pubkey"
						}
					}
				},
				{
					name: "fallback_clusters",
					docs: [
						"Fallback clusters that can execute this MXE as an alternative to the",
						"[MXEAccount::cluster]. There can be a maximum of [MAX_FALLBACK_CLUSTERS]",
						"fallback clusters."
					],
					type: {
						vec: "u32"
					}
				},
				{
					name: "rejected_clusters",
					docs: [
						"The clusters that have rejected this MXE."
					],
					type: {
						vec: "u32"
					}
				},
				{
					name: "computation_definitions",
					docs: [
						"The offsets of all [ComputationDefinitionAccount]s of this MXE."
					],
					type: {
						vec: "u32"
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "MediumExecPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "ExecutingPool",
							generics: [
								{
									kind: "const",
									value: "10"
								}
							]
						}
					}
				}
			]
		}
	},
	{
		name: "MediumMempool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "MediumMempoolInner"
						}
					}
				}
			]
		}
	},
	{
		name: "MediumMempoolInner",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "last_updated_slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							5
						]
					}
				},
				{
					name: "computations",
					type: {
						defined: {
							name: "MediumMempoolInnerBuffer"
						}
					}
				}
			]
		}
	},
	{
		name: "MediumMempoolInnerBuffer",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "elems",
					type: {
						array: [
							{
								defined: {
									name: "MediumMempoolInnerBufferHeap"
								}
							},
							180
						]
					}
				},
				{
					name: "valid_bits",
					docs: [
						"Bit array tracking which slots are valid (1 = valid, 0 = stale)",
						"1 bit per slot, packed into bytes. For $buffer_length=180, this is 23 bytes."
					],
					type: {
						array: [
							"u8",
							23
						]
					}
				},
				{
					name: "start_index",
					type: "u8"
				},
				{
					name: "length",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				}
			]
		}
	},
	{
		name: "MediumMempoolInnerBufferHeap",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "entries",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							10
						]
					}
				},
				{
					name: "count",
					type: "u16"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				}
			]
		}
	},
	{
		name: "MempoolSize",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Tiny"
				},
				{
					name: "Small"
				},
				{
					name: "Medium"
				},
				{
					name: "Large"
				}
			]
		}
	},
	{
		name: "NodeMetadata",
		docs: [
			"location as [ISO 3166-1 alpha-2](https://www.iso.org/iso-3166-country-codes.html) country code"
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "ip",
					docs: [
						"[Ipv4Addr], represented by it's 4 octects"
					],
					type: {
						array: [
							"u8",
							4
						]
					}
				},
				{
					name: "peer_id",
					docs: [
						"Needed for MPC protocol"
					],
					type: {
						array: [
							"u8",
							32
						]
					}
				},
				{
					name: "location",
					type: "u8"
				}
			]
		}
	},
	{
		name: "NodeRef",
		docs: [
			"A reference to a node in the cluster.",
			"The offset is to derive the Node Account.",
			"The current_total_rewards is the total rewards the node has received so far in the current",
			"epoch."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "offset",
					type: "u32"
				},
				{
					name: "current_total_rewards",
					docs: [
						"Current total rewards the node has received in the current epoch in lamports."
					],
					type: "u64"
				},
				{
					name: "vote",
					type: "u8"
				}
			]
		}
	},
	{
		name: "OffChainCircuitSource",
		type: {
			kind: "struct",
			fields: [
				{
					name: "source",
					type: "string"
				},
				{
					name: "hash",
					type: {
						array: [
							"u8",
							32
						]
					}
				}
			]
		}
	},
	{
		name: "OnChainCircuitSource",
		type: {
			kind: "struct",
			fields: [
				{
					name: "is_completed",
					docs: [
						"Specifies if the circuit for this computation has been fully uploaded,",
						"as this can take multiple transactions due to the circuit size."
					],
					type: "bool"
				},
				{
					name: "upload_auth",
					docs: [
						"The authority that is allowed to upload the circuit."
					],
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "Operator",
		type: {
			kind: "struct",
			fields: [
				{
					name: "node_offsets",
					type: {
						vec: "u32"
					}
				},
				{
					name: "meta",
					type: {
						defined: {
							name: "OperatorMeta"
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "OperatorMeta",
		docs: [
			"location as [ISO 3166-1 alpha-2](https://www.iso.org/iso-3166-country-codes.html) country code"
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "url",
					docs: [
						"URL should point to a JSON containing the following fields:",
						"- `name`: String, the name of the operator",
						"- `description`: String, a description of the operator",
						"- `icon`: String, a URL to an icon representing the operator",
						"- `url`: String, a URL to the operator's website"
					],
					type: "string"
				},
				{
					name: "location",
					type: "u8"
				}
			]
		}
	},
	{
		name: "Output",
		docs: [
			"An output of a computation.",
			"We currently don't support encrypted outputs yet since encrypted values are passed via",
			"data objects."
		],
		type: {
			kind: "enum",
			variants: [
				{
					name: "PlaintextBool"
				},
				{
					name: "PlaintextU8"
				},
				{
					name: "PlaintextU16"
				},
				{
					name: "PlaintextU32"
				},
				{
					name: "PlaintextU64"
				},
				{
					name: "PlaintextU128"
				},
				{
					name: "Ciphertext"
				},
				{
					name: "ArcisPubkey"
				},
				{
					name: "PlaintextFloat"
				}
			]
		}
	},
	{
		name: "Parameter",
		docs: [
			"A parameter of a computation.",
			"We differentiate between plaintext and encrypted parameters and data objects.",
			"Plaintext parameters are directly provided as their value.",
			"Encrypted parameters are provided as an offchain reference to the data.",
			"Data objects are provided as a reference to the data object account."
		],
		type: {
			kind: "enum",
			variants: [
				{
					name: "PlaintextBool"
				},
				{
					name: "PlaintextU8"
				},
				{
					name: "PlaintextU16"
				},
				{
					name: "PlaintextU32"
				},
				{
					name: "PlaintextU64"
				},
				{
					name: "PlaintextU128"
				},
				{
					name: "Ciphertext"
				},
				{
					name: "ArcisPubkey"
				},
				{
					name: "ArcisSignature"
				},
				{
					name: "PlaintextFloat"
				},
				{
					name: "ManticoreAlgo"
				},
				{
					name: "InputDataset"
				}
			]
		}
	},
	{
		name: "QueueComputationEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "SmallExecPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "ExecutingPool",
							generics: [
								{
									kind: "const",
									value: "3"
								}
							]
						}
					}
				}
			]
		}
	},
	{
		name: "SmallMempool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "SmallMempoolInner"
						}
					}
				}
			]
		}
	},
	{
		name: "SmallMempoolInner",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "last_updated_slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							5
						]
					}
				},
				{
					name: "computations",
					type: {
						defined: {
							name: "SmallMempoolInnerBuffer"
						}
					}
				}
			]
		}
	},
	{
		name: "SmallMempoolInnerBuffer",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "elems",
					type: {
						array: [
							{
								defined: {
									name: "SmallMempoolInnerBufferHeap"
								}
							},
							180
						]
					}
				},
				{
					name: "valid_bits",
					docs: [
						"Bit array tracking which slots are valid (1 = valid, 0 = stale)",
						"1 bit per slot, packed into bytes. For $buffer_length=180, this is 23 bytes."
					],
					type: {
						array: [
							"u8",
							23
						]
					}
				},
				{
					name: "start_index",
					type: "u8"
				},
				{
					name: "length",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				}
			]
		}
	},
	{
		name: "SmallMempoolInnerBufferHeap",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "entries",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							3
						]
					}
				},
				{
					name: "count",
					type: "u16"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				}
			]
		}
	},
	{
		name: "Timestamp",
		type: {
			kind: "struct",
			fields: [
				{
					name: "timestamp",
					type: "u64"
				}
			]
		}
	},
	{
		name: "TinyExecPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "ExecutingPool",
							generics: [
								{
									kind: "const",
									value: "1"
								}
							]
						}
					}
				}
			]
		}
	},
	{
		name: "TinyMempool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "TinyMempoolInner"
						}
					}
				}
			]
		}
	},
	{
		name: "TinyMempoolInner",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "last_updated_slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							5
						]
					}
				},
				{
					name: "computations",
					type: {
						defined: {
							name: "TinyMempoolInnerBuffer"
						}
					}
				}
			]
		}
	},
	{
		name: "TinyMempoolInnerBuffer",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "elems",
					type: {
						array: [
							{
								defined: {
									name: "TinyMempoolInnerBufferHeap"
								}
							},
							180
						]
					}
				},
				{
					name: "valid_bits",
					docs: [
						"Bit array tracking which slots are valid (1 = valid, 0 = stale)",
						"1 bit per slot, packed into bytes. For $buffer_length=180, this is 23 bytes."
					],
					type: {
						array: [
							"u8",
							23
						]
					}
				},
				{
					name: "start_index",
					type: "u8"
				},
				{
					name: "length",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				}
			]
		}
	},
	{
		name: "TinyMempoolInnerBufferHeap",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "entries",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							1
						]
					}
				},
				{
					name: "count",
					type: "u16"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				}
			]
		}
	},
	{
		name: "X25519Pubkey",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Set",
					fields: [
						{
							array: [
								"u8",
								32
							]
						}
					]
				},
				{
					name: "Unset",
					fields: [
						{
							array: [
								"u8",
								32
							]
						},
						{
							vec: "bool"
						}
					]
				}
			]
		}
	}
];
var arcium = {
	address: address,
	metadata: metadata,
	instructions: instructions,
	accounts: accounts,
	events: events,
	errors: errors,
	types: types
};

var ARCIUM_IDL = /*#__PURE__*/Object.freeze({
    __proto__: null,
    accounts: accounts,
    address: address,
    default: arcium,
    errors: errors,
    events: events,
    instructions: instructions,
    metadata: metadata,
    types: types
});

/**
 * The deployed address of the Arcium program, as specified in the IDL.
 */
const ARCIUM_ADDR = address;

/**
 * Seed for ClockAccount PDA
 * @constant {string}
 */
const CLOCK_ACC_SEED = 'ClockAccount';
/**
 * Seed for StakingPoolAccount PDA
 * @constant {string}
 */
const POOL_ACC_SEED = 'StakingPoolAccount';
/**
 * Seed for ComputationAccount PDA
 * @constant {string}
 */
const COMPUTATION_ACC_SEED = 'ComputationAccount';
/**
 * Seed for Mempool PDA
 * @constant {string}
 */
const MEMPOOL_ACC_SEED = 'Mempool';
/**
 * Seed for ExecutingPoolAccount PDA
 * @constant {string}
 */
const EXEC_POOL_ACC_SEED = 'Execpool';
/**
 * Seed for ClusterAccount PDA
 * @constant {string}
 */
const CLUSTER_ACC_SEED = 'Cluster';
/**
 * Seed for ArxNodeAccount PDA
 * @constant {string}
 */
const ARX_NODE_ACC_SEED = 'ArxNode';
/**
 * Seed for MXEAccAccount PDA
 * @constant {string}
 */
const MXE_ACC_ACC_SEED = 'MXEAccount';
/**
 * Seed for CompDefAccount PDA
 * @constant {string}
 */
const COMP_DEF_ACC_SEED = 'ComputationDefinitionAccount';
/**
 * Maximum number of bytes that can be reallocated per instruction.
 * @constant {number}
 */
const MAX_REALLOC_PER_IX = 10240;
/**
 * Maximum number of bytes that can be uploaded in a single transaction with the upload instruction.
 * @constant {number}
 */
const MAX_UPLOAD_PER_TX_BYTES = 814;
/**
 * Maximum size of an account in bytes (10MB = 10 * 1024 * 1024).
 * @constant {number}
 */
const MAX_ACCOUNT_SIZE = 10485760;
/**
 * Maximum number of arcium embiggen instructions allowed in a single transaction (due to compute unit limits).
 * @constant {number}
 */
const MAX_EMBIGGEN_IX_PER_TX = 18;

/**
 * Returns the public key of the deployed Arcium program on Solana.
 * @returns The Arcium program's public key.
 */
function getArciumProgramId() {
    return new web3_js.PublicKey('BKck65TgoKRokMjQM3datB9oRwJ8rAj2jxPXvHXUvcL6');
}
/**
 * Derives the computation account address for a given MXE program ID and offset.
 * @param mxeProgramId - The public key of the MXE program.
 * @param offset - The computation offset as an anchor.BN.
 * @returns The derived computation account public key.
 */
function getComputationAccAddress(mxeProgramId, offset) {
    const seeds = [Buffer.from(COMPUTATION_ACC_SEED), mxeProgramId.toBuffer(), offset.toArrayLike(Buffer, 'le', 8)];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the mempool account address for a given MXE program ID.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns The derived mempool account public key.
 */
function getMempoolAccAddress(mxeProgramId) {
    const seeds = [Buffer.from(MEMPOOL_ACC_SEED), mxeProgramId.toBuffer()];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the executing pool account address for a given MXE program ID.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns The derived executing pool account public key.
 */
function getExecutingPoolAccAddress(mxeProgramId) {
    const seeds = [Buffer.from(EXEC_POOL_ACC_SEED), mxeProgramId.toBuffer()];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the staking pool account address.
 * @returns The derived staking pool account public key.
 */
function getStakingPoolAccAddress() {
    const seeds = [Buffer.from(POOL_ACC_SEED)];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the clock account address.
 * @returns The derived clock account public key.
 */
function getClockAccAddress() {
    const seeds = [Buffer.from(CLOCK_ACC_SEED)];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the cluster account address for a given offset.
 * @param offset - The cluster offset as a number.
 * @returns The derived cluster account public key.
 */
function getClusterAccAddress(offset) {
    const offsetBuffer = Buffer.alloc(4);
    offsetBuffer.writeUInt32LE(offset, 0);
    const seeds = [Buffer.from(CLUSTER_ACC_SEED), offsetBuffer];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the ArxNode account address for a given offset.
 * @param offset - The ArxNode offset as a number.
 * @returns The derived ArxNode account public key.
 */
function getArxNodeAccAddress(offset) {
    const offsetBuffer = Buffer.alloc(4);
    offsetBuffer.writeUInt32LE(offset, 0);
    const seeds = [Buffer.from(ARX_NODE_ACC_SEED), offsetBuffer];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the MXE account address for a given MXE program ID.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns The derived MXE account public key.
 */
function getMXEAccAddress(mxeProgramId) {
    const seeds = [Buffer.from(MXE_ACC_ACC_SEED), mxeProgramId.toBuffer()];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the computation definition account address for a given MXE program ID and offset.
 * @param mxeProgramId - The public key of the MXE program.
 * @param offset - The computation definition offset as a number.
 * @returns The derived computation definition account public key.
 */
function getCompDefAccAddress(mxeProgramId, offset) {
    const offsetBuffer = Buffer.alloc(4);
    offsetBuffer.writeUInt32LE(offset, 0);
    const seeds = [Buffer.from(COMP_DEF_ACC_SEED), mxeProgramId.toBuffer(), offsetBuffer];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Generates a program-derived address (PDA) from the provided seeds and the Arcium program ID.
 * @param seeds - An array of Buffer seeds used for PDA derivation.
 * @returns A tuple containing the derived public key and the bump seed.
 */
function generateArciumPDAFrom(seeds) {
    const programId = getArciumProgramId();
    return web3_js.PublicKey.findProgramAddressSync(seeds, programId);
}

const TINY_MEMPOOL_ACC_NAME = 'tinyMempool';
const TINY_MEMPOOL_DISCRIMINATOR = [
    176,
    33,
    67,
    108,
    73,
    135,
    110,
    166,
];
const TINY_EXECPOOL_ACC_NAME = 'tinyExecPool';
const TINY_EXECPOOL_DISCRIMINATOR = [
    80,
    245,
    5,
    90,
    154,
    189,
    190,
    172,
];
const SMALL_MEMPOOL_ACC_NAME = 'smallMempool';
const SMALL_MEMPOOL_DISCRIMINATOR = [
    123,
    153,
    151,
    118,
    126,
    71,
    73,
    92,
];
const SMALL_EXECPOOL_ACC_NAME = 'smallExecPool';
const SMALL_EXECPOOL_DISCRIMINATOR = [
    37,
    147,
    249,
    253,
    217,
    136,
    3,
    87,
];
const MEDIUM_MEMPOOL_ACC_NAME = 'mediumMempool';
const MEDIUM_MEMPOOL_DISCRIMINATOR = [
    10,
    249,
    58,
    39,
    255,
    231,
    199,
    168,
];
const MEDIUM_EXECPOOL_ACC_NAME = 'mediumExecPool';
const MEDIUM_EXECPOOL_DISCRIMINATOR = [
    97,
    117,
    128,
    202,
    213,
    76,
    5,
    163,
];
const LARGE_MEMPOOL_ACC_NAME = 'largeMempool';
const LARGE_MEMPOOL_DISCRIMINATOR = [
    16,
    168,
    90,
    235,
    249,
    207,
    73,
    223,
];
const LARGE_EXECPOOL_ACC_NAME = 'largeExecPool';
const LARGE_EXECPOOL_DISCRIMINATOR = [
    147,
    145,
    148,
    170,
    30,
    13,
    43,
    216,
];
const MEMPOOL_DISCRIMINATOR_MAP = {
    [TINY_MEMPOOL_DISCRIMINATOR.toString()]: TINY_MEMPOOL_ACC_NAME,
    [SMALL_MEMPOOL_DISCRIMINATOR.toString()]: SMALL_MEMPOOL_ACC_NAME,
    [MEDIUM_MEMPOOL_DISCRIMINATOR.toString()]: MEDIUM_MEMPOOL_ACC_NAME,
    [LARGE_MEMPOOL_DISCRIMINATOR.toString()]: LARGE_MEMPOOL_ACC_NAME,
};
const EXECPOOL_DISCRIMINATOR_MAP = {
    [TINY_EXECPOOL_DISCRIMINATOR.toString()]: TINY_EXECPOOL_ACC_NAME,
    [SMALL_EXECPOOL_DISCRIMINATOR.toString()]: SMALL_EXECPOOL_ACC_NAME,
    [MEDIUM_EXECPOOL_DISCRIMINATOR.toString()]: MEDIUM_EXECPOOL_ACC_NAME,
    [LARGE_EXECPOOL_DISCRIMINATOR.toString()]: LARGE_EXECPOOL_ACC_NAME,
};
/**
 * Returns the public key of the deployed Arcium program on Solana.
 * @returns The Arcium program's public key.
 */
function getArciumProgAddress() {
    return new anchor__namespace.web3.PublicKey(ARCIUM_ADDR);
}
/**
 * Fetches and decodes the mempool account data for any mempool account size.
 * @param provider - The Anchor provider to use for fetching accounts.
 * @param mempoolAccPubkey - The public key of the mempool account.
 * @returns The decoded mempool account data.
 * @throws Error if the account cannot be fetched or the discriminator is unknown.
 */
async function getMempoolAccData(provider, mempoolAccPubkey) {
    const accData = await provider.connection.getAccountInfo(mempoolAccPubkey);
    if (accData === null) {
        throw new Error(`Failed to fetch mempool account ${mempoolAccPubkey.toBase58()}`);
    }
    const discriminator = Array.from(accData.data.subarray(0, 8)).toString();
    const accName = MEMPOOL_DISCRIMINATOR_MAP[discriminator];
    if (accName === undefined) {
        throw new Error(`Unknown mempool account discriminator: ${discriminator}`);
    }
    const program = getArciumProgram(provider);
    return program.coder.accounts.decode(accName, accData.data);
}
/**
 * Fetches and decodes the executing pool account data for any pool size.
 * @param provider - The Anchor provider to use for fetching accounts.
 * @param executingPoolAccPubkey - The public key of the executing pool account.
 * @returns The decoded executing pool account data.
 * @throws Error if the account cannot be fetched or the discriminator is unknown.
 */
async function getExecutingPoolAccData(provider, executingPoolAccPubkey) {
    const accData = await provider.connection.getAccountInfo(executingPoolAccPubkey);
    if (accData === null) {
        throw new Error(`Failed to fetch executing pool account ${executingPoolAccPubkey.toBase58()}`);
    }
    const discriminator = Array.from(accData.data.subarray(0, 8)).toString();
    const accName = EXECPOOL_DISCRIMINATOR_MAP[discriminator];
    if (accName === undefined) {
        throw new Error(`Unknown executing pool account discriminator: ${discriminator}`);
    }
    const program = getArciumProgram(provider);
    return program.coder.accounts.decode(accName, accData.data);
}
/**
 * Fetches and extracts the MXE public key from the MXE account.
 * @param provider - The Anchor provider to use for fetching accounts.
 * @param mxeProgramID - The public key of the MXE program.
 * @returns The MXE's x25519 public key as a Uint8Array, or null if not set.
 */
async function getMXEPublicKey(provider, mxeProgramID) {
    const program = getArciumProgram(provider);
    const mxeAccAddress = getMXEAccAddress(mxeProgramID);
    const mxeAccInfo = await program.account.mxeAccount.fetch(mxeAccAddress);
    if ('set' in mxeAccInfo.x25519Pubkey) {
        const setData = mxeAccInfo.x25519Pubkey.set;
        return new Uint8Array([...setData[0]]);
    }
    else if ('unset' in mxeAccInfo.x25519Pubkey) {
        const unsetData = mxeAccInfo.x25519Pubkey.unset;
        if (unsetData[1].every(Boolean)) {
            return new Uint8Array([...unsetData[0]]);
        }
    }
    return null;
}
/**
 * Uploads a circuit to the blockchain, splitting it into multiple accounts if necessary.
 * @param provider - The Anchor provider to use for transactions.
 * @param circuitName - The name of the circuit.
 * @param mxeProgramID - The public key of the MXE program.
 * @param rawCircuit - The raw circuit data as a Uint8Array.
 * @param logging - Whether to log progress (default: true).
 * @param chunkSize - The number of upload transactions to send in parallel (default: 500).
 * @returns An array of transaction signatures for all upload and finalize transactions.
 */
async function uploadCircuit(provider, circuitName, mxeProgramID, rawCircuit, logging = true, chunkSize = 500) {
    const numAccs = Math.ceil(rawCircuit.length / (MAX_ACCOUNT_SIZE - 9));
    const compDefAccInfo = getCompDefAccInfo(circuitName, mxeProgramID);
    const program = getArciumProgram(provider);
    const sigs = [];
    const uploadPromises = [];
    for (let i = 0; i < numAccs; i++) {
        uploadPromises.push(uploadToCircuitAcc(provider, program, rawCircuit.subarray(i * (MAX_ACCOUNT_SIZE - 9), (i + 1) * (MAX_ACCOUNT_SIZE - 9)), i, compDefAccInfo, mxeProgramID, logging, chunkSize));
    }
    sigs.push(...(await Promise.all(uploadPromises)).flat());
    const finalizeCompDefTx = await buildFinalizeCompDefTx(provider, compDefAccInfo.offset, mxeProgramID);
    sigs.push(await signAndSendWithBlockhash(provider, finalizeCompDefTx, await provider.connection.getLatestBlockhash()));
    return sigs;
}
/**
 * Builds a transaction to finalize a computation definition.
 * @param provider - The Anchor provider to use for transactions.
 * @param compDefOffset - The offset of the computation definition.
 * @param mxeProgramID - The public key of the MXE program.
 * @returns The transaction to finalize the computation definition.
 */
async function buildFinalizeCompDefTx(provider, compDefOffset, mxeProgramID) {
    const program = getArciumProgram(provider);
    const compDefOffsetBuffer = Buffer.alloc(4);
    compDefOffsetBuffer.writeUInt32LE(compDefOffset, 0);
    return program.methods
        .finalizeComputationDefinition(compDefOffset, mxeProgramID)
        .accounts({
        signer: provider.publicKey,
    })
        .transaction();
}
async function uploadToCircuitAcc(provider, program, rawCircuitPart, rawCircuitIndex, compDefAccInfo, mxeProgramID, shouldLog = true, chunkSize = 500) {
    const sigs = [];
    const initTx = await program.methods
        .initRawCircuitAcc(compDefAccInfo.offset, mxeProgramID, rawCircuitIndex)
        .accounts({
        signer: provider.publicKey,
    })
        .rpc();
    optionalLog(shouldLog, `Initiated raw circuit acc with raw circuit index ${rawCircuitIndex}`);
    sigs.push(initTx);
    if (rawCircuitPart.length > MAX_REALLOC_PER_IX) {
        // We only need to add size if the init didn't already make us big enough
        const nonAsyncTxCount = Math.ceil(rawCircuitPart.length / (MAX_REALLOC_PER_IX * MAX_EMBIGGEN_IX_PER_TX));
        for (let i = 0; i < nonAsyncTxCount; i++) {
            optionalLog(shouldLog, `Sending resize tx ${i} of ${nonAsyncTxCount}`);
            // eslint-disable-next-line no-await-in-loop
            const tx = await buildResizeTx(program, provider.publicKey, compDefAccInfo, mxeProgramID, rawCircuitIndex, MAX_REALLOC_PER_IX
                + i * (MAX_REALLOC_PER_IX * MAX_EMBIGGEN_IX_PER_TX), rawCircuitPart.length);
            // eslint-disable-next-line no-await-in-loop
            const blockInfo = await provider.connection.getLatestBlockhash();
            sigs.push(
            // eslint-disable-next-line no-await-in-loop
            await signAndSendWithBlockhash(provider, tx, blockInfo));
            optionalLog(shouldLog, `Sent resize tx ${i} of ${nonAsyncTxCount}`);
        }
    }
    optionalLog(shouldLog, 'Done sending resize txs');
    // The previous txs have allocated all the space we need now, so we can send the remaining upload txs async to one another now
    const remainingTxCount = Math.ceil(rawCircuitPart.length / MAX_UPLOAD_PER_TX_BYTES);
    optionalLog(shouldLog, `Sending ${remainingTxCount} upload txs`);
    const remainingTxs = [];
    const blockInfo = await provider.connection.getLatestBlockhash();
    for (let i = 0; i < remainingTxCount; i += chunkSize) {
        optionalLog(shouldLog, `Sending chunk ${i / chunkSize + 1} of ${Math.ceil(remainingTxCount / chunkSize)}`);
        const chunkPromises = []; // Array to hold promises for the current chunk
        const currentChunkSize = Math.min(chunkSize, remainingTxCount - i); // Handle the last chunk
        for (let j = 0; j < currentChunkSize; j++) {
            const offset = MAX_UPLOAD_PER_TX_BYTES * (i + j);
            // eslint-disable-next-line no-await-in-loop
            const tx = await buildUploadCircuitTx(program, provider.publicKey, compDefAccInfo, mxeProgramID, Buffer.copyBytesFrom(rawCircuitPart, offset, MAX_UPLOAD_PER_TX_BYTES), offset, rawCircuitIndex);
            chunkPromises.push(signAndSendWithBlockhash(provider, tx, blockInfo));
        }
        // Wait for the current chunk to complete before proceeding
        // eslint-disable-next-line no-await-in-loop
        const chunkResults = await Promise.all(chunkPromises);
        remainingTxs.push(...chunkResults); // Add the results of the current chunk to the main array
        optionalLog(shouldLog, `Done sending chunk ${i / chunkSize + 1} of ${Math.ceil(remainingTxCount / chunkSize)}`);
    }
    return sigs.concat(remainingTxs);
}
async function buildResizeTx(program, signerPubkey, compDefAccInfo, mxeProgramID, rawCircuitIndex, currentSize, requiredSize) {
    const ix = await program.methods
        .embiggenRawCircuitAcc(compDefAccInfo.offset, mxeProgramID, rawCircuitIndex)
        .accounts({
        signer: signerPubkey,
    })
        .instruction();
    const resizeSize = Math.min(requiredSize - currentSize, MAX_EMBIGGEN_IX_PER_TX * MAX_REALLOC_PER_IX);
    // We might alloc a bit too much here, but that's ok because we fix it in the upload tx
    const ixCount = Math.ceil(resizeSize / MAX_REALLOC_PER_IX);
    const tx = new anchor__namespace.web3.Transaction();
    for (let i = 0; i < ixCount; i++) {
        tx.add(ix);
    }
    return tx;
}
async function buildUploadCircuitTx(program, signerPubkey, compDefAccInfo, mxeProgramID, bytes, circuitOffset, rawCircuitIndex) {
    if (bytes.length > MAX_UPLOAD_PER_TX_BYTES) {
        throw new Error('Upload circuit bytes must be 814 bytes or less per tx');
    }
    let bytesInner = bytes;
    if (bytesInner.length < MAX_UPLOAD_PER_TX_BYTES) {
        const paddedBytes = Buffer.allocUnsafe(MAX_UPLOAD_PER_TX_BYTES);
        paddedBytes.set(bytesInner);
        bytesInner = paddedBytes;
    }
    return program.methods
        .uploadCircuit(compDefAccInfo.offset, mxeProgramID, rawCircuitIndex, Array.from(bytesInner), circuitOffset)
        .accounts({
        signer: signerPubkey,
    })
        .transaction();
}
async function signAndSendWithBlockhash(provider, tx, block) {
    // eslint-disable-next-line no-param-reassign
    tx.recentBlockhash = block.blockhash;
    // eslint-disable-next-line no-param-reassign
    tx.lastValidBlockHeight = block.lastValidBlockHeight;
    return provider.sendAndConfirm(tx, [], { commitment: 'confirmed' });
}
/**
 * Returns the base seed for an Arcium account, given its name.
 * @param accName - The name of the account.
 * @returns The base seed as a Uint8Array.
 */
function getArciumAccountBaseSeed(accName) {
    return Buffer.from(accName, 'utf-8');
}
/**
 * Computes the offset for a computation definition account, based on the circuit name.
 * @param circuitName - The name of the circuit.
 * @returns The offset as a 4-byte Uint8Array.
 */
function getCompDefAccOffset(circuitName) {
    const hash = new Uint8Array(sha256([Buffer.from(circuitName, 'utf-8')]));
    return hash.slice(0, 4);
}
/**
 * Returns an Anchor program instance for the Arcium program.
 * @param provider - The Anchor provider to use.
 * @returns The Anchor program instance for Arcium.
 */
function getArciumProgram(provider) {
    return new anchor.Program(ARCIUM_IDL, provider);
}
/**
 * Returns a read-only Anchor program instance for the Arcium program.
 * @param provider - The Anchor provider to use.
 * @returns The Anchor program instance for Arcium.
 */
function getArciumProgramReadonly(provider) {
    return new anchor.Program(ARCIUM_IDL, provider);
}
/**
 * Returns the PDA (program-derived address) for an ArxNode account given the program ID and node offset.
 * @param arciumProgramID - The public key of the Arcium program.
 * @param nodeOffset - The offset of the node.
 * @returns The PDA for the ArxNode account.
 */
function getArxAccPDA(arciumProgramID, nodeOffset) {
    const nodeOffsetBuffer = Buffer.alloc(4);
    nodeOffsetBuffer.writeUInt32LE(nodeOffset, 0);
    return anchor__namespace.web3.PublicKey.findProgramAddressSync([Buffer.from('ArxNode', 'utf-8'), nodeOffsetBuffer], arciumProgramID)[0];
}
/**
 * Returns the public key and offset for a computation definition account, given the circuit name and MXE program ID.
 * @param circuitName - The name of the circuit.
 * @param mxeProgramID - The public key of the MXE program.
 * @returns An object containing the public key and offset for the computation definition account.
 */
function getCompDefAccInfo(circuitName, mxeProgramID) {
    const offset = getCompDefAccOffset(circuitName);
    const pda = getCompDefAccPDA(getArciumProgAddress(), mxeProgramID, offset);
    return { pubkey: pda, offset: Buffer.from(offset).readUInt32LE(0) };
}
/**
 * Returns the PDA for a computation definition account, given the program ID, MXE program ID, and offset.
 * @param arciumProgramID - The public key of the Arcium program.
 * @param mxeProgramID - The public key of the MXE program.
 * @param offset - The offset as a Uint8Array.
 * @returns The PDA for the computation definition account.
 */
function getCompDefAccPDA(arciumProgramID, mxeProgramID, offset) {
    return anchor__namespace.web3.PublicKey.findProgramAddressSync([Buffer.from('ComputationDefinitionAccount', 'utf-8'), mxeProgramID.toBuffer(), offset], arciumProgramID)[0];
}

/**
 * Reads local Arcium environment information from environment variables.
 * Only available in Node.js and when testing locally.
 * @returns The local Arcium environment configuration.
 * @throws Error if called in a browser or if required environment variables are missing or invalid.
 */
function getArciumEnv() {
    if (isBrowser()) {
        throw new Error('Arcium local env is not available in browser.');
    }
    // eslint-disable-next-line global-require, @typescript-eslint/no-var-requires
    const process = require('process');
    try {
        // const arxNodePubkey = new PublicKey(process.env.ARX_NODE_PUBKEY);
        const arciumClusterPubkey = new web3_js.PublicKey(process.env.ARCIUM_CLUSTER_PUBKEY);
        return {
            arciumClusterPubkey,
        };
    }
    catch (e) {
        throw new Error(`Encountered error while trying to parse env vars: ${e}`);
    }
}

/**
 * Waits for the finalization of a computation by listening for the finalizeComputationEvent.
 * Resolves with the transaction signature once the computation is finalized.
 * @param provider - The Anchor provider to use for event listening.
 * @param computationOffset - The offset of the computation to wait for.
 * @param mxeProgramId - The public key of the MXE program.
 * @param commitment - (Optional) The desired finality/commitment level (default: 'confirmed').
 * @returns The transaction signature of the finalization event.
 */
async function awaitComputationFinalization(provider, computationOffset, mxeProgramId, commitment = 'confirmed') {
    const arciumProgram = getArciumProgram(provider);
    const eventListener = new anchor.EventManager(arciumProgram.programId, provider, arciumProgram.coder);
    const finalizeComp = await awaitEvent(eventListener, 'finalizeComputationEvent', (e) => mxeProgramId.equals(e.mxeProgramId) && e.computationOffset.eq(computationOffset), commitment);
    return finalizeComp.sig;
}
/**
 * Waits for a specific event to occur, matching a custom check, and returns the event and its signature.
 * @param eventListener - The EventManager instance to use for listening.
 * @param eventName - The name of the event to listen for.
 * @param eventCheck - A predicate function to check if the event matches the desired criteria.
 * @param commitment - (Optional) The desired finality/commitment level (default: 'confirmed').
 * @returns An object containing the event and its transaction signature.
 */
async function awaitEvent(eventListener, eventName, eventCheck, commitment = 'confirmed') {
    const foundEvent = await new Promise((res) => {
        const listenerId = eventListener.addEventListener(eventName, (event, _slot, signature) => {
            if (eventCheck(event))
                res([event, signature, listenerId]);
        }, commitment);
    });
    await eventListener.removeEventListener(foundEvent[2]);
    return { event: foundEvent[0], sig: foundEvent[1] };
}

Object.defineProperty(exports, "x25519", {
    enumerable: true,
    get: function () { return ed25519.x25519; }
});
exports.ARCIUM_ADDR = ARCIUM_ADDR;
exports.ARCIUM_IDL = ARCIUM_IDL;
exports.Aes128Cipher = Aes128Cipher;
exports.Aes192Cipher = Aes192Cipher;
exports.Aes256Cipher = Aes256Cipher;
exports.CURVE25519_BASE_FIELD = CURVE25519_BASE_FIELD;
exports.CURVE25519_SCALAR_FIELD_MODULUS = CURVE25519_SCALAR_FIELD_MODULUS;
exports.Matrix = Matrix;
exports.RescueCipher = RescueCipher;
exports.RescueDesc = RescueDesc;
exports.RescuePrimeHash = RescuePrimeHash;
exports.arcisEd25519 = arcisEd25519;
exports.awaitComputationFinalization = awaitComputationFinalization;
exports.buildFinalizeCompDefTx = buildFinalizeCompDefTx;
exports.compressUint128 = compressUint128;
exports.decompressUint128 = decompressUint128;
exports.deserializeLE = deserializeLE;
exports.generateRandomFieldElem = generateRandomFieldElem;
exports.getArciumAccountBaseSeed = getArciumAccountBaseSeed;
exports.getArciumEnv = getArciumEnv;
exports.getArciumProgAddress = getArciumProgAddress;
exports.getArciumProgram = getArciumProgram;
exports.getArciumProgramId = getArciumProgramId;
exports.getArciumProgramReadonly = getArciumProgramReadonly;
exports.getArxAccPDA = getArxAccPDA;
exports.getArxNodeAccAddress = getArxNodeAccAddress;
exports.getClockAccAddress = getClockAccAddress;
exports.getClusterAccAddress = getClusterAccAddress;
exports.getCompDefAccAddress = getCompDefAccAddress;
exports.getCompDefAccOffset = getCompDefAccOffset;
exports.getComputationAccAddress = getComputationAccAddress;
exports.getExecutingPoolAccAddress = getExecutingPoolAccAddress;
exports.getExecutingPoolAccData = getExecutingPoolAccData;
exports.getMXEAccAddress = getMXEAccAddress;
exports.getMXEPublicKey = getMXEPublicKey;
exports.getMempoolAccAddress = getMempoolAccAddress;
exports.getMempoolAccData = getMempoolAccData;
exports.getStakingPoolAccAddress = getStakingPoolAccAddress;
exports.positiveModulo = positiveModulo;
exports.randMatrix = randMatrix;
exports.serializeLE = serializeLE;
exports.sha256 = sha256;
exports.toVec = toVec;
exports.uploadCircuit = uploadCircuit;
